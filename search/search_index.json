{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pymwp","text":"<p>pymwp is an implementation of MWP analysis on C code in Python.</p>"},{"location":"#introduction","title":"Introduction","text":"<p>pymwp is a tool for automatically performing static analysis on programs written in C. It analyzes resource usage and determines if a program's variables growth rates are no more than polynomially related to their inputs sizes. </p> <p>For example,</p> <pre><code>int main(int X1, int X2, int X3){\n    X1 = X2 + X3;\n    X1 = X1 + X1;\n}\n</code></pre> <p>is satisfactory because\u2014between the initial variable values (<code>Xi</code>) and the final values (<code>Xi'</code>)\u2014all variables have a polynomially bounded data-flow (omitting constants):     <code>X1' \u2264 X2+X3</code> and <code>X2' \u2264 X2</code>  and <code>X3' \u2264 X3</code>. pymwp derives this bound automatically (\u2bc8 demo).</p> <p>However, program</p> <pre><code>int main(int X1, int X2, int X3){\n   X1 = 1;\n   while (X2 &gt; 0){ X1 = X1 + X1; }\n}   \n</code></pre> <p>fails the analysis, because <code>X1</code> grows exponentially (<code>X1'</code> = \\(2^{\\texttt{X2}}\\)).    pymwp reports a program is infinite when no polynomial bound can be derived (\u2bc8 demo).</p> <p>pymwp is inspired by \"A Flow Calculus of mwp-Bounds for Complexity Analysis\". Try our online demo to see it action. For more details, see pymwp documentation, particularly supported C language features.</p>"},{"location":"#documentation-and-demo","title":"Documentation and Demo","text":"<ul> <li> <p>Documentation: statycc.github.io/pymwp</p> </li> <li> <p>Demo: online demo and input examples</p> </li> <li> <p>Publication: \"pymwp: A Static Analyzer Determining Polynomial Growth Bounds\", also on HAL.</p> </li> <li> <p>Tool user guide: statycc.github.io/.github/pymwp with detailed examples and discussion.</p> </li> </ul> <p>The user guide is the ideal place to start for a general and interactive introduction to pymwp.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install the latest release from PyPI</p> <pre><code>pip install pymwp\n</code></pre>"},{"location":"#how-to-use","title":"How to Use","text":"<p>Command-Line Use</p> <p>To analyze a C file, run in terminal:</p> <pre><code>pymwp path/to_some_file.c\n</code></pre> <p>For a list of available command options and help, run:</p> <pre><code>pymwp\n</code></pre> <p>Use in Python Scripts</p> <p>You can also use pymwp by importing it in a Python script. See modules documentation for details and examples.</p>"},{"location":"#running-from-source","title":"Running from source","text":"<p>If you want to use the latest stable version\u2014possibly ahead of the latest release, and with special evaluation utilities and input examples\u2014use pymwp directly from source.</p> <ol> <li> <p>Clone the repository</p> <pre><code>git clone https://github.com/statycc/pymwp.git \ncd pymwp\n</code></pre> </li> <li> <p>Set up Python runtime environment of preference</p> <p> \u00a0 Using Python venv\u2197</p> <p>Create and activate a virtual environment (POSIX bash/zsh): <pre><code>python3 -m venv venv\nsource venv/bin/activate\n</code></pre> <pre><code>python -m pip install -r requirements.txt\n</code></pre> <pre><code>python -m pip install -r requirements-dev.txt\n</code></pre></p> <p>Install required packages:</p> <p>For development, install dev-dependencies instead:</p> <p> \u00a0 Using Docker\u2197</p> <p>Build a container -- also installs dev-dependencies: <pre><code>docker build . -t pymwp\n</code></pre> <pre><code>docker run --rm -v \"$(pwd):$(pwd)\" pymwp\n</code></pre></p> <p>Run the container:</p> </li> <li> <p>Run the analysis</p> <p>From project root run:</p> <pre><code>python -m pymwp path/to_some_file.c\n</code></pre> <p>for example:</p> <pre><code>python -m pymwp c_files/basics/if.c\n</code></pre> <p>for all available options and help, run:</p> <pre><code>python -m pymwp\n</code></pre> </li> </ol>"},{"location":"analysis/","title":"pymwp Analysis","text":"<pre><code>from pymwp import Analysis\n</code></pre>"},{"location":"analysis/#pymwp.analysis.Analysis","title":"Analysis","text":"<p>MWP analysis implementation.</p>"},{"location":"analysis/#pymwp.analysis.Analysis.binary_op","title":"binary_op  <code>staticmethod</code>","text":"<pre><code>binary_op(index: int, node: Assignment) -&gt; COM_RES\n</code></pre> <p>Analyze binary operation, e.g. <code>x = y + z</code>.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>delta index</p> required <code>node</code> <code>Assignment</code> <p>AST node representing a binary operation</p> required <p>Returns:</p> Type Description <code>COM_RES</code> <p>Updated index value, relation list, and an exit flag.</p>"},{"location":"analysis/#pymwp.analysis.Analysis.cmds","title":"cmds  <code>staticmethod</code>","text":"<pre><code>cmds(\n    relations: RelationList, index: int, nodes: List[Node], stop: bool = True\n) -&gt; Tuple[bool, int]\n</code></pre> <p>Analyze some list of commands, typically body block statements.</p> <p>Parameters:</p> Name Type Description Default <code>relations</code> <code>RelationList</code> <p>Initialized relation list.</p> required <code>index</code> <code>int</code> <p>Derivation index.</p> required <code>nodes</code> <code>List[Node]</code> <p>List of AST nodes to analyze.</p> required <code>stop</code> <code>bool</code> <p>Set True to terminate early.</p> <code>True</code> <p>Returns:</p> Type Description <code>Tuple[bool, int]</code> <p>True if nodes lead to infinity by delta graph.</p>"},{"location":"analysis/#pymwp.analysis.Analysis.compound","title":"compound  <code>staticmethod</code>","text":"<pre><code>compound(index: int, node: Compound, dg: DeltaGraph) -&gt; COM_RES\n</code></pre> <p>Compound AST node contains zero or more children and is created by braces in source code.</p> <p>We analyze such compound node by recursively analysing its children.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Delta index.</p> required <code>node</code> <code>Compound</code> <p>Compound AST node.</p> required <code>dg</code> <code>DeltaGraph</code> <p>DeltaGraph instance.</p> required <p>Returns:</p> Type Description <code>COM_RES</code> <p>Updated index value, relation list, and an exit flag.</p>"},{"location":"analysis/#pymwp.analysis.Analysis.compute_relation","title":"compute_relation  <code>staticmethod</code>","text":"<pre><code>compute_relation(index: int, node: Node, dg: DeltaGraph) -&gt; COM_RES\n</code></pre> <p>Create a relation list corresponding for all possible matrices of an AST node.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Delta index.</p> required <code>node</code> <code>Node</code> <p>AST node to analyze.</p> required <code>dg</code> <code>DeltaGraph</code> <p>DeltaGraph instance.</p> required <p>Returns:</p> Type Description <code>COM_RES</code> <p>Updated index value, relation list, and an exit flag.</p>"},{"location":"analysis/#pymwp.analysis.Analysis.constant","title":"constant  <code>staticmethod</code>","text":"<pre><code>constant(index: int, variable_name: str) -&gt; COM_RES\n</code></pre> <p>Analyze a constant assignment of form <code>x = c</code> where x is some variable and c is constant.</p> <p>From \"A Flow Calculus of mwp-Bounds...\"</p> <p>To deal with constants, just replace the program\u2019s constants by variables and regard the replaced constants as input to these variables.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>delta index</p> required <code>variable_name</code> <code>str</code> <p>name of variable to which constant is being assigned</p> required <p>Returns:</p> Type Description <code>COM_RES</code> <p>Updated index value, relation list, and an exit flag.</p>"},{"location":"analysis/#pymwp.analysis.Analysis.create_vector","title":"create_vector  <code>staticmethod</code>","text":"<pre><code>create_vector(\n    index: int, op: str, variables: Tuple[str, ...]\n) -&gt; Tuple[int, List[Polynomial]]\n</code></pre> <p>Build a polynomial vector based on operator and the operands of a binary operation statement that has form <code>x = y (operator) z</code>.</p> <p>For an AST node that represents a binary operation, this method generates a vector of polynomials based on the properties of that operation. The returned vector depends on the type of operator, how many operands are constants, and if the operands are equal.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>delta index</p> required <code>op</code> <code>str</code> <p>operator</p> required <code>variables</code> <code>Tuple[str, ...]</code> <p>variables in this operation <code>x = y (op) z</code> in order, where <code>y</code> or <code>z</code> is <code>None</code> if constant</p> required <p>Returns:</p> Type Description <code>Tuple[int, List[Polynomial]]</code> <p>Updated index, list of Polynomial vectors</p>"},{"location":"analysis/#pymwp.analysis.Analysis.for_loop","title":"for_loop  <code>staticmethod</code>","text":"<pre><code>for_loop(index: int, node: For, dg: DeltaGraph) -&gt; COM_RES\n</code></pre> <p>Analyze for loop node.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Delta index.</p> required <code>node</code> <code>For</code> <p>for loop node.</p> required <code>dg</code> <code>DeltaGraph</code> <p>DeltaGraph instance.</p> required <p>Returns:</p> Type Description <code>COM_RES</code> <p>Updated index value, relation list, and an exit flag.</p>"},{"location":"analysis/#pymwp.analysis.Analysis.func","title":"func  <code>staticmethod</code>","text":"<pre><code>func(node: FuncDef, stop: bool) -&gt; FuncResult\n</code></pre> <p>Analyze a function.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>FuncDef</code> <p>parsed C source code function node</p> required <code>stop</code> <code>bool</code> <p>terminate if no bound exists</p> required <p>Returns:</p> Type Description <code>FuncResult</code> <p>Analysis result for provided function.</p>"},{"location":"analysis/#pymwp.analysis.Analysis.id","title":"id  <code>staticmethod</code>","text":"<pre><code>id(index: int, node: Assignment) -&gt; COM_RES\n</code></pre> <p>Analyze x = y, where data flows between two variables.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>delta index</p> required <code>node</code> <code>Assignment</code> <p>AST node representing a simple assignment</p> required <p>Returns:</p> Type Description <code>COM_RES</code> <p>Updated index value, relation list, and an exit flag.</p>"},{"location":"analysis/#pymwp.analysis.Analysis.if_branch","title":"if_branch  <code>staticmethod</code>","text":"<pre><code>if_branch(\n    index: int, node: If, relation_list: RelationList, dg: DeltaGraph\n) -&gt; Tuple[int, bool]\n</code></pre> <p>Analyze <code>if</code> or <code>else</code> branch of a conditional statement.</p> <p>This method will analyze the body of the statement and update the provided relation. It can handle blocks with or without surrounding braces. It will return the updated index value.</p> <p>If branch does not exist (when else case is omitted) this method does nothing and returns the original index value without modification.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Current delta index value.</p> required <code>node</code> <code>If</code> <p>AST if statement branch node.</p> required <code>relation_list</code> <code>RelationList</code> <p>Current relation list state.</p> required <code>dg</code> <code>DeltaGraph</code> <p>DeltaGraph instance.</p> required <p>Returns:</p> Type Description <code>Tuple[int, bool]</code> <p>Updated index value, relation list, and an exit flag.</p>"},{"location":"analysis/#pymwp.analysis.Analysis.if_stmt","title":"if_stmt  <code>staticmethod</code>","text":"<pre><code>if_stmt(index: int, node: If, dg: DeltaGraph) -&gt; COM_RES\n</code></pre> <p>Analyze an if statement.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Delta index.</p> required <code>node</code> <code>If</code> <p>if-statement AST node.</p> required <code>dg</code> <code>DeltaGraph</code> <p>DeltaGraph instance.</p> required <p>Returns:</p> Type Description <code>COM_RES</code> <p>Updated index value, relation list, and an exit flag.</p>"},{"location":"analysis/#pymwp.analysis.Analysis.rewrite_id_inc_dec","title":"rewrite_id_inc_dec  <code>staticmethod</code>","text":"<pre><code>rewrite_id_inc_dec(node: UnaryOp)\n</code></pre> <p>Converts unary ++/-- operators to binary: x = x (op) 1.</p>"},{"location":"analysis/#pymwp.analysis.Analysis.rm_cast","title":"rm_cast  <code>staticmethod</code>","text":"<pre><code>rm_cast(node: Node) -&gt; Node\n</code></pre> <p>If Cast node, returns the expression of cast.</p>"},{"location":"analysis/#pymwp.analysis.Analysis.run","title":"run  <code>staticmethod</code>","text":"<pre><code>run(\n    ast: Node,\n    res: Result = None,\n    fin: bool = False,\n    strict: bool = False,\n    **kwargs\n) -&gt; Result\n</code></pre> <p>Run MWP analysis on AST.</p> <p>Parameters:</p> Name Type Description Default <code>ast</code> <code>Node</code> <p>Parsed C source code AST Node.</p> required <code>res</code> <code>Result</code> <p>Pre-initialized result object.</p> <code>None</code> <code>fin</code> <code>bool</code> <p>Always run to completion.</p> <code>False</code> <code>strict</code> <code>bool</code> <p>Require supported syntax.</p> <code>False</code> <p>Returns:</p> Type Description <code>Result</code> <p>Analysis Result object.</p>"},{"location":"analysis/#pymwp.analysis.Analysis.syntax_check","title":"syntax_check  <code>staticmethod</code>","text":"<pre><code>syntax_check(node: Node, strict: bool) -&gt; bool\n</code></pre> <p>Analyze function syntax and conditionally modify the AST.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>An AST node.</p> required <code>strict</code> <code>bool</code> <p>When true, AST will not be modified.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if analysis can be performed and False otherwise.</p>"},{"location":"analysis/#pymwp.analysis.Analysis.take_counts","title":"take_counts  <code>staticmethod</code>","text":"<pre><code>take_counts(ast: Node, result: Result) -&gt; None\n</code></pre> <p>Calculate program statistics: functions, loops, and variables.</p> <p>Parameters:</p> Name Type Description Default <code>ast</code> <code>Node</code> <p>Parsed C source code AST Node.</p> required <code>result</code> <code>Result</code> <p>Pre-initialized result object.</p> required"},{"location":"analysis/#pymwp.analysis.Analysis.unary_asgn","title":"unary_asgn  <code>staticmethod</code>","text":"<pre><code>unary_asgn(index: int, node: Assignment, dg: DeltaGraph) -&gt; COM_RES\n</code></pre> <p>Assignment where right-hand-size is a unary op e.g. <code>x = y++;</code>.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>delta index</p> required <code>node</code> <code>Assignment</code> <p>Node with right-side unary operation.</p> required <code>dg</code> <code>DeltaGraph</code> <p>DeltaGraph instance.</p> required <p>Returns:</p> Type Description <code>COM_RES</code> <p>Updated index value, relation list, and an exit flag.</p>"},{"location":"analysis/#pymwp.analysis.Analysis.unary_op","title":"unary_op  <code>staticmethod</code>","text":"<pre><code>unary_op(index: int, node: UnaryOp) -&gt; COM_RES\n</code></pre> <p>Analyze a standalone unary operation.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Delta index.</p> required <code>node</code> <code>UnaryOp</code> <p>AST node to analyze.</p> required <p>Returns:</p> Type Description <code>COM_RES</code> <p>Updated index value, relation list, and an exit flag.</p>"},{"location":"analysis/#pymwp.analysis.Analysis.while_loop","title":"while_loop  <code>staticmethod</code>","text":"<pre><code>while_loop(index: int, node: While, dg: DeltaGraph) -&gt; COM_RES\n</code></pre> <p>Analyze a while loop.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Delta index.</p> required <code>node</code> <code>pr.while</code> <p>While loop node.</p> required <code>dg</code> <code>DeltaGraph</code> <p>DeltaGraph instance.</p> required <p>Returns:</p> Type Description <code>COM_RES</code> <p>Updated index value, relation list, and an exit flag.</p>"},{"location":"analysis/#pymwp.analysis.LoopAnalysis","title":"LoopAnalysis","text":"<p>               Bases: <code>Analysis</code></p> <p>MWP analysis for loops.</p>"},{"location":"analysis/#pymwp.analysis.LoopAnalysis.get_result","title":"get_result  <code>staticmethod</code>","text":"<pre><code>get_result(relation: Relation, index: int, v_name: str) -&gt; VResult\n</code></pre> <p>Find variable bounds when they are known to exist.</p> <p>Parameters:</p> Name Type Description Default <code>relation</code> <code>Relation</code> <p>Relation object.</p> required <code>index</code> <code>int</code> <p>Degree of analysis choice.</p> required <code>v_name</code> <code>str</code> <p>Name of variable to evaluate.</p> required <p>Returns:</p> Type Description <code>VResult</code> <p>Evaluation result for identified variable.</p>"},{"location":"analysis/#pymwp.analysis.LoopAnalysis.inspect","title":"inspect  <code>staticmethod</code>","text":"<pre><code>inspect(node: LoopT) -&gt; LoopResult\n</code></pre> <p>Analyze a loop.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>LOOP_T</code> <p>A loop node.</p> required <p>Returns:</p> Type Description <code>LoopResult</code> <p>Loop analysis result.</p>"},{"location":"analysis/#pymwp.analysis.LoopAnalysis.maybe_result","title":"maybe_result  <code>staticmethod</code>","text":"<pre><code>maybe_result(relation: Relation, index: int) -&gt; Dict[str, VResult]\n</code></pre> <p>Evaluate variables when some variables are known to fail.</p> <p>Parameters:</p> Name Type Description Default <code>relation</code> <code>Relation</code> <p>Relation object.</p> required <code>index</code> <code>int</code> <p>Degree of analysis choice.</p> required <p>Returns:</p> Type Description <code>Dict[str, VResult]</code> <p>Dictionary of results, for each variable in relation.</p>"},{"location":"analysis/#pymwp.analysis.LoopAnalysis.run","title":"run  <code>staticmethod</code>","text":"<pre><code>run(ast: Node, res: Result = None, strict: bool = False, **kwargs) -&gt; Result\n</code></pre> <p>Run loop analysis.</p> <p>Parameters:</p> Name Type Description Default <code>ast</code> <code>Node</code> <p>Parsed C source code as an AST.</p> required <code>res</code> <code>Result</code> <p>Pre-initialized result object.</p> <code>None</code> <code>strict</code> <code>bool</code> <p>Require supported syntax.</p> <code>False</code> <p>Returns:</p> Type Description <code>Result</code> <p>Analysis Result object.</p>"},{"location":"analysis/#pymwp.analysis.LoopAnalysis.syntax_check","title":"syntax_check  <code>staticmethod</code>","text":"<pre><code>syntax_check(node: LoopT, strict: bool) -&gt; bool\n</code></pre> <p>Analyze function syntax and conditionally modify the AST.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>LOOP_T</code> <p>An AST loop node.</p> required <code>strict</code> <code>bool</code> <p>When true, AST will not be modified.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if analysis can be performed and False otherwise.</p>"},{"location":"bound/","title":"bound.py","text":"<pre><code>from pymwp import Bound\n</code></pre>"},{"location":"bound/#pymwp.bound.Bound","title":"Bound","text":"<pre><code>Bound(bounds: dict[str, str] = None)\n</code></pre> <p>Represents a mwp-bound for a relation. If derivation succeeds, there is one mwp-bound expression for each input variable.</p> <p>Attributes:</p> Name Type Description <code>bound_dict</code> <code>Dict[str, MwpBound]</code> <p>Variable bounds.</p> <p>Create a bound.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>dict[str, str]</code> <p>Dictionary of mwp-bounds.</p> <code>None</code>"},{"location":"bound/#pymwp.bound.Bound.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: List[str]\n</code></pre> <p>List of variables.</p>"},{"location":"bound/#pymwp.bound.Bound.calculate","title":"calculate","text":"<pre><code>calculate(relation: SimpleRelation) -&gt; Bound\n</code></pre> <p>Calculate bound from a simple-valued matrix.</p> <p>Parameters:</p> Name Type Description Default <code>relation</code> <code>SimpleRelation</code> <p>A simple-valued relation.</p> required <p>Returns:</p> Type Description <code>Bound</code> <p>The bound for the relation.</p>"},{"location":"bound/#pymwp.bound.Bound.show","title":"show","text":"<pre><code>show(\n    compact: bool = False,\n    significant: bool = False,\n    variables: Tuple[str] = None,\n) -&gt; str\n</code></pre> <p>Formatted display-string of a bound.</p> <p>Parameters:</p> Name Type Description Default <code>compact</code> <code>bool</code> <p>reduce whitespace in the output</p> <code>False</code> <code>significant</code> <code>bool</code> <p>omit bounds that depend only on self</p> <code>False</code> <code>variables</code> <code>Tuple[str]</code> <p>list of variables to display</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A formatted string of the bound.</p>"},{"location":"bound/#pymwp.bound.Bound.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>A dictionary representation of a bound.</p>"},{"location":"bound/#pymwp.bound.HonestPoly","title":"HonestPoly","text":"<pre><code>HonestPoly(operator: str, *init_vars: str)\n</code></pre> <p>Models an honest polynomial.</p> <p>Attributes:</p> Name Type Description <code>variables</code> <code>set[str]</code> <p>List of variables.</p> <code>var_fmt(Callable)</code> <code>set[str]</code> <p>Variable formatter.</p> <code>op</code> <code>str</code> <p>Operator.</p> <p>Creates a honest polynomial.</p> <p>Parameters:</p> Name Type Description Default <code>operator</code> <code>str</code> <p>Operator.</p> required <code>*init_vars</code> <code>str</code> <p>Arbitrary variables.</p> <code>()</code>"},{"location":"bound/#pymwp.bound.HonestPoly.empty","title":"empty  <code>property</code>","text":"<pre><code>empty: bool\n</code></pre> <p>True if honest polynomial is empty.</p>"},{"location":"bound/#pymwp.bound.HonestPoly.value","title":"value  <code>property</code>","text":"<pre><code>value: Union[int, str]\n</code></pre> <p>String representation of HP value.</p>"},{"location":"bound/#pymwp.bound.HonestPoly.vars","title":"vars  <code>property</code>","text":"<pre><code>vars: List[str]\n</code></pre> <p>Sorted list of variables.</p>"},{"location":"bound/#pymwp.bound.HonestPoly.add","title":"add","text":"<pre><code>add(*identifier: str)\n</code></pre> <p>Add variables to HP.</p>"},{"location":"bound/#pymwp.bound.MaxVar","title":"MaxVar","text":"<pre><code>MaxVar(*init_vars: str)\n</code></pre> <p>               Bases: <code>HonestPoly</code></p> <p>Representation for m-variables.</p>"},{"location":"bound/#pymwp.bound.MwpBound","title":"MwpBound","text":"<pre><code>MwpBound(triple: str = None)\n</code></pre> <p>Represents a mwp-bound.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>Tuple[str]</code> <p>List of m-variables.</p> <code>y</code> <code>Tuple[str]</code> <p>List of w-variables.</p> <code>z</code> <code>Tuple[str]</code> <p>List of p-variables.</p> <p>Create mwp-bound.</p> <p>Parameters:</p> Name Type Description Default <code>triple</code> <code>str</code> <p>Bound expression as bound_str.</p> <code>None</code>"},{"location":"bound/#pymwp.bound.MwpBound.bound_str","title":"bound_str  <code>property</code>","text":"<pre><code>bound_str: str\n</code></pre> <p>Alternative bounds representation, as a <code>;</code>-separated string.</p> <p>Returns:</p> Type Description <code>str</code> <p>Current bound as \\(m;w;p\\) where the first section contains list of variables in m, second contains variables in w, and last in p (if any). Multiple elements in the lists are separated by commas.</p>"},{"location":"bound/#pymwp.bound.MwpBound.bound_triple","title":"bound_triple  <code>property</code>","text":"<pre><code>bound_triple: B_TRIPLE\n</code></pre> <p>Alternative bounds representation, as three tuples.</p> <p>Returns:</p> Type Description <code>B_TRIPLE</code> <p>Current bound as \\((m_1,...m_n), (w_1,...w_n), (p_1,...p_n)\\) where the first contains list of variables in m, second contains variables in w, and last in p (if any).</p>"},{"location":"bound/#pymwp.bound.MwpBound.append","title":"append","text":"<pre><code>append(scalar: str, var_name: str)\n</code></pre> <p>Append variable dependency in the right list by scalar.</p>"},{"location":"bound/#pymwp.bound.MwpBound.parse","title":"parse  <code>staticmethod</code>","text":"<pre><code>parse(value: str = None) -&gt; B_TRIPLE\n</code></pre> <p>Restore a bound from string-triple format.</p>"},{"location":"choice/","title":"Choice.py","text":"<pre><code>from pymwp import Choices\n</code></pre> <p>Choice module generates a compact representation of analysis derivation result.</p> <p>The Choice module allows determining valid derivation choices and analyzing available choices. By default, the term valid means derivations that do not fail, i.e., give \\(\\infty\\) in matrix;  but other interpretations of valid choice can be defined also.</p> Determining valid derivation choices <p>Inputs:</p> <ul> <li><code>index</code>: <code>int</code> degree of choice; total number of derivation choices in an analyzed program.               </li> <li><code>domain</code>: <code>List[int]</code> possible inference choices at a program point, e.g. <code>[0,1,2]</code>.               </li> <li><code>delta_sequences</code>: <code>Set[SEQ]</code> sequences of choices  to negate.</li> </ul> <p>For example, to obtain derivation choices excluding failing derivations (\\(\\infty\\) in matrix), the <code>delta_sequences</code> should be all sequences of deltas with scalar <code>i</code>.</p> <p>The choice module converts the delta sequences to their negated choices, in a compact regular expression-like format:</p> <pre><code># Input:\nindex = 3\ndomain = [0, 1, 2]\ndelta_sequences = {((0, 0), (2, 1)), ((1, 1),)}\n\n# Output:\n[[[1, 2], [0, 2], [0, 1, 2]], \n [[0, 1, 2], [0], [0, 1, 2]]] \n</code></pre> <p>A regular expression matching the output is <code>([1|2][0|2][0-2])|([0-2]0[0-2])</code>.</p> Steps <ol> <li> <p>Simplify. Using \\(\\delta\\)-sequences set, simplify it:</p> <ol> <li>Replace combinations that can be represented by a single shorter sequence.</li> <li>Remove supersets.</li> <li>Preemptively remove deltas that would lead to invalid choice vectors.</li> </ol> <p>Apply simplifications iteratively until convergence.</p> <p>Simplifications</p> <p>This example assumes domain = <code>[0,1,2]</code>.</p> <p>(A) All possible choices occur at index 0: any choice followed by sequence <code>(2,1)(1,2)</code> results in infinity. Therefore, remove \\(a, b, c\\) and insert <code>[(2,1)(1,2)]</code> in their place. Choices are reduced similarly from both ends.</p> <pre><code>BEFORE                           AFTER\n[(0,0)(2,1)(1,2)]     # a        [(2,1)(1,2)]\n[(1,0)(2,1)(1,2)]     # b\n[(2,0)(2,1)(1,2)]     # c\n</code></pre> <p>(B) Sequence \\(a\\) is subset of \\(b\\). Since \\(b\\) cannot be selected without selecting \\(a\\), discard \\(b\\).</p> <pre><code>BEFORE                           AFTER\n[(0,0)]               # a        [(0,0)]\n[(0,0)(0,1)(2,2)]     # b\n</code></pre> <p>(C) Constructing a choice vector requires selecting deltas from each remaining sequence \\(a, b, c\\). Therefore, deltas <code>(0,0)</code> and <code>(1,0)</code>  must always be selected, and one of \\(c\\), <code>[(2,0)(2,1)(1,2)]</code>. However,  selecting <code>(0,0)</code>, <code>(1,0)</code>, and <code>(2,0)</code> eliminates all choices at index 0.  This allows to reduce sequences \\(c\\) to <code>(2,1)(1,2)</code>.</p> <pre><code>BEFORE                           AFTER\n[(0,0)]               # a        [(0,0)]\n[(1,0)]               # b        [(1,0)] \n[(2,0)(2,1)(1,2)]     # c        [(2,1)(1,2)]\n</code></pre> </li> <li> <p>Build choice vectors. Initially consider all choices as valid.    Then eliminate unwanted sequences, for all possible combinations.</p> <p>Compute cross product of remaining \\(\\delta\\)-sequences. Iterate the product, for each:</p> <ul> <li>Create a vector whose length is <code>index</code>.</li> <li>Each vector element is a set of choices defined by <code>domain</code>.</li> <li>Eliminate choices that lead to an unwanted outcome.</li> </ul> <p>Discard invalid and redundant vectors. Add remaining vectors to result.</p> <p>Choice vector generation</p> <pre><code># remaining after simplification\nsequences = [[(0,0)], [(1,0)], [(2,1)(1,2)], [(2,0)(1,1)(1,2)]]\n\n# compute a cross product of sequences (6 total)\nchoice_paths = [[(0,0) (1,0) (2,1) (2,0)],\n                [(0,0) (1,0) (2,1) (1,1)],\n                [(0,0) (1,0) (2,1) (1,2)],\u2026]\n\nfor each path:\n\n    # initialize a vector with all choices at each index\n    vector_init = [{0,1,2}, {0,1,2}, {0,1,2}]\n\n    # eliminate path choices, and add to result:\n    vector_final = [[2], [0], [0,1,2]] \n</code></pre> </li> <li> <p>Result. The result is a disjunction of choice vectors.     Choose one vector, then select one value at each vector index.      This yields a valid derivation result. For example, for a choice vector,</p> <pre><code>[[[2], [0],   [0,1,2]],\n [[1], [1,2], [0,1,2]]]  \n</code></pre> <p>selecting \\((1, 2, 2)\\) is valid choice, so is \\((2, 0, 2)\\) and \\((1, 1, 0)\\), \u2026etc.</p> <ul> <li>If all choices are valid, the Choice vector has a single vector permitting all choices.</li> <li>If no valid derivation exists, the result is empty choice: <code>[ ]</code>.</li> <li>If <code>index=0</code>, i.e., no choice needs to be made, also result is empty <code>[ ]</code>.</li> </ul> </li> </ol>"},{"location":"choice/#pymwp.choice.Choices","title":"Choices","text":"<pre><code>Choices(valid: CHOICES = None, index: int = -1)\n</code></pre> <p>A compact representation of derivation choices.</p> <p>Attributes:</p> Name Type Description <code>valid</code> <code>CHOICES</code> <p>list of choice vectors.</p> <code>index</code> <code>int</code> <p>degree of choice.</p> <p>Initialize representation from a precomputed vector.</p> <p>This is primarily useful for restoring a result from file. To create a choice representation, call <code>generate()</code> instead.</p>"},{"location":"choice/#pymwp.choice.Choices.first","title":"first  <code>property</code>","text":"<pre><code>first: Optional[tuple[int]]\n</code></pre> <p>Gets the first valid derivation choice, if at least one exists.</p>"},{"location":"choice/#pymwp.choice.Choices.infinite","title":"infinite  <code>property</code>","text":"<pre><code>infinite\n</code></pre> <p>True if no valid choice exists.</p>"},{"location":"choice/#pymwp.choice.Choices.n_bounds","title":"n_bounds  <code>property</code>","text":"<pre><code>n_bounds: int\n</code></pre> <p>Number of bounds that can be generated from a choice vector. This is calculated directly from the vector form. It is the product of number of choices at each index: \\(\\prod_{c \\in v} |c|\\).</p> Example <ol> <li> <p>Vector <code>[[0, 1, 2], [0, 1, 2], [0]]</code> allows making <code>[3, 3, 1]</code>    choices/index. It has \\(3 * 3 * 1 = 9\\) total bounds.</p> </li> <li> <p>A vector with choices/index: <code>[3, 1, 2, 1, 3, 3]</code> has     \\(3^3 * 2^1 * 1^2 = 54\\) possible bounds.</p> </li> </ol> <p>Returns:</p> Type Description <code>int</code> <p>Number of possible choices (non-distinct).</p>"},{"location":"choice/#pymwp.choice.Choices.all","title":"all","text":"<pre><code>all() -&gt; Generator[Tuple[int, ...]]\n</code></pre> <p>Generator for all valid derivation choices.</p> Note <p>Calling this method is very inefficient. Generally, we do not want to generate all choices. The method yields the next value in series, so it is possible to step through the choices one at a time. Use with caution/only call if necessary.</p> <p>Yields:</p> Type Description <code>Generator[Tuple[int, ...]]</code> <p>The next valid choice.</p>"},{"location":"choice/#pymwp.choice.Choices.build_choices","title":"build_choices  <code>staticmethod</code>","text":"<pre><code>build_choices(domain: List[int], index: int, infinities: Set[SEQ]) -&gt; CHOICES\n</code></pre> <p>Build a list of distinct choice vectors excluding unwanted choices.</p> <p>This method works by taking a list of delta paths that give unwanted scalars (e.g., \\(\\infty\\)) and then negates those choices; the result is a list of choice vectors such that any remaining choice will give a valid derivation.</p> Example <ul> <li>Assume paths leading to \\(\\infty\\) are:   <code>[(0,0)], [(1,0)], [(1,1)(0,3)]</code>.</li> <li>The choices that do not lead to \\(\\infty\\) are:   <code>[[[2], [0,2], [0,1,2]]</code> or <code>[[2], [0,1,2], [1,2]]]</code>.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>List[int]</code> <p>list of valid choices for one index, e.g. <code>[0, 1, 2]</code>.</p> required <code>index</code> <code>int</code> <p>the length of the vector, e.g. 10.</p> required <code>infinities</code> <code>Set[SEQ]</code> <p>set of deltas that lead to unwanted choices.</p> required <p>Returns:</p> Type Description <code>CHOICES</code> <p>Choice vector that excludes all paths leading to unwanted choices.</p>"},{"location":"choice/#pymwp.choice.Choices.except_one","title":"except_one  <code>staticmethod</code>","text":"<pre><code>except_one(domain: List[int], sequences: Set[SEQ]) -&gt; Set[SEQ]\n</code></pre> <p>Look for deltas of length=1 where all-but-one choices are made at same index. The remaining one choice can be eliminated from paths that contain it, because it would yield an invalid choice vector.</p> Example <p>Given sequence <code>((0,0),), ((1,0),), ((2,0),(2,1),(1,4),)</code> and the goal to build a choice vector. Deltas <code>(0,0)</code> and <code>(1,0)</code> must be chosen. For <code>((2,0),(2,1),(1,4),)</code> one of the deltas must be chosen. But choosing <code>(0,0), (1,0), (2,0)</code> eliminates all choices at index 0. It suffices to keep sequence <code>((0,0),), ((1,0),), ((2,1),(1,4),)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>List[int]</code> <p>list of valid per index choices, e.g. <code>[0, 1, 2]</code>.</p> required <code>sequences</code> <code>Set[SEQ]</code> <p>set of delta sequences.</p> required <p>Returns:</p> Type Description <code>Set[SEQ]</code> <p>A set of sequences after applying simplification.</p>"},{"location":"choice/#pymwp.choice.Choices.generate","title":"generate  <code>staticmethod</code>","text":"<pre><code>generate(domain: List[int], index: int, inf: Set[SEQ]) -&gt; Choices\n</code></pre> <p>Generate the choice representation.</p> <p>This works in two steps: (1) simplify delta sequences, (2) build choice vectors.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>List[int]</code> <p>valid choices at index, e.g. <code>[0, 1, 2]</code>.</p> required <code>index</code> <code>int</code> <p>the length of the vector, e.g. 10. This is the same as number of assignments in the analyzed function.</p> required <code>inf</code> <code>Set[SEQ]</code> <p>set of deltas that lead to infinity.</p> required <p>Returns:</p> Type Description <code>Choices</code> <p>Generated choice object.</p>"},{"location":"choice/#pymwp.choice.Choices.intersection","title":"intersection  <code>staticmethod</code>","text":"<pre><code>intersection(c1: Choices, c2: Choices) -&gt; Choices\n</code></pre> <p>Intersection of two choice vectors.</p> <p>Intersection is a cross-product of non-empty vector intersections. If the none of the vectors intersect, the resulting Choice is empty.</p> <p>Parameters:</p> Name Type Description Default <code>c1</code> <code>Choices</code> <p>First Choice vector.</p> required <code>c2</code> <code>Choices</code> <p>Second Choice vector.</p> required <p>Returns:</p> Type Description <code>Choices</code> <p>New Choices representing the intersection of the two arguments.</p>"},{"location":"choice/#pymwp.choice.Choices.is_valid","title":"is_valid","text":"<pre><code>is_valid(*choices: int) -&gt; bool\n</code></pre> <p>Checks if sequence of choices can be made without infinity.</p> Example <pre><code>choice_obj.is_valid(0, 1, 2, 1, 1, 0)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>choices</code> <code>int</code> <p>sequences of delta values to check.</p> <code>()</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the given choices can be made without infinity.</p>"},{"location":"choice/#pymwp.choice.Choices.prod","title":"prod  <code>staticmethod</code>","text":"<pre><code>prod(values: list) -&gt; int\n</code></pre> <p>Compute the product of numeric list.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>list</code> <p>1d list of numbers.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Product of values.</p>"},{"location":"choice/#pymwp.choice.Choices.reduce","title":"reduce  <code>staticmethod</code>","text":"<pre><code>reduce(domain: List[int], sequences: Set[SEQ]) -&gt; bool\n</code></pre> <p>Look for first reducible sequence, if exists, then replace it.</p> Example <p>We can reduce a sequences where deltas differ only on first value, never on index, and all possible choice values are represented in the first delta. Below, it does not matter which choice is made at index 0. The 3 paths can be collapsed into a single, shorter path: <code>(2,1)(1,4)</code>.</p> <pre><code>(0,0) (2,1) (1,4)\n(1,0) (2,1) (1,4)\n(2,0) (2,1) (1,4)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>List[int]</code> <p>list of valid per index choices, e.g. <code>[0, 1, 2]</code>.</p> required <code>sequences</code> <code>Set[SEQ]</code> <p>set of delta sequences.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if a reduction occurred and False otherwise. The meaning of False is to say the operation is done and should not be repeated any further.</p>"},{"location":"choice/#pymwp.choice.Choices.reduce_end","title":"reduce_end  <code>staticmethod</code>","text":"<pre><code>reduce_end(domain: List[int], sequences: Set[SEQ]) -&gt; bool\n</code></pre> <p>Like <code>reduce</code>, but from end of sequence.</p> Example <p>When deltas only differ at last index, and all choices occur at last index, reduce choices to a shorter path. E.g., Below, choice at index 5 is irrelevant; keep <code>(2,1) (1,4)</code>.</p> <pre><code>(2,1) (1,4) (0,5)\n(2,1) (1,4) (1,5)\n(2,1) (1,4) (2,5)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>List[int]</code> <p>list of valid per index choices, e.g. <code>[0, 1, 2]</code>.</p> required <code>sequences</code> <code>Set[SEQ]</code> <p>set of delta sequences.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if a reduction occurred and False otherwise.</p>"},{"location":"choice/#pymwp.choice.Choices.remove_subset","title":"remove_subset  <code>staticmethod</code>","text":"<pre><code>remove_subset(match: SEQ, items: Union[Set, List])\n</code></pre> <p>If <code>match</code> is a subset of any item in <code>items</code>, removes the superset from items, in place.</p> <p>Parameters:</p> Name Type Description Default <code>match</code> <code>SEQ</code> <p>single delta sequence.</p> required <code>items</code> <code>Union[Set, List]</code> <p>list of delta sequences to check against match.</p> required"},{"location":"choice/#pymwp.choice.Choices.simplify","title":"simplify  <code>staticmethod</code>","text":"<pre><code>simplify(domain: List[int], sequences: Set[SEQ]) -&gt; Set[SEQ]\n</code></pre> <p>Generate the most simplified, equivalent representation of the set of choices that cause unwanted derivation results.</p> <p>Reduce sequences of deltas, until set of sequences cannot be reduced any further. Then remove all superset contained by some shorter sequence. Lastly, remove deltas that would generate an invalid choice vector. This process repeats until no more simplification can be applied.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>List[int]</code> <p>list of valid per index choices, e.g. <code>[0, 1, 2]</code>.</p> required <code>sequences</code> <code>Set[SEQ]</code> <p>set of delta sequences.</p> required <p>Returns:</p> Type Description <code>Set[SEQ]</code> <p>Simplified list of infinity paths.</p>"},{"location":"choice/#pymwp.choice.Choices.sub_equal","title":"sub_equal  <code>staticmethod</code>","text":"<pre><code>sub_equal(first: SEQ, second: SEQ) -&gt; bool\n</code></pre> <p>Compare two delta sequences for equality, except their 0th value.</p> <p>Parameters:</p> Name Type Description Default <code>first</code> <code>SEQ</code> <p>first delta sequence.</p> required <code>second</code> <code>SEQ</code> <p>second delta sequence.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if two delta sequences are equal excluding the 0th value, and False otherwise.</p>"},{"location":"choice/#pymwp.choice.Choices.sub_equal_end","title":"sub_equal_end  <code>staticmethod</code>","text":"<pre><code>sub_equal_end(first: SEQ, second: SEQ) -&gt; bool\n</code></pre> <p>Compare two delta sequences for equality, except their N-th value. This is like <code>sub_equal</code>, but comparison is done at the end of sequences.</p> <p>Parameters:</p> Name Type Description Default <code>first</code> <code>SEQ</code> <p>first delta sequence.</p> required <code>second</code> <code>SEQ</code> <p>second delta sequence.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if two delta sequences are equal excluding the N-th value, and False otherwise.</p>"},{"location":"choice/#pymwp.choice.Choices.to_choices","title":"to_choices  <code>staticmethod</code>","text":"<pre><code>to_choices(vectors: List[VECT]) -&gt; CHOICES\n</code></pre> <p>Convert a list of vectors to CHOICES type. This is a simple type conversion over the inner collection-types.</p>"},{"location":"choice/#pymwp.choice.Choices.unique_sequences","title":"unique_sequences  <code>staticmethod</code>","text":"<pre><code>unique_sequences(infinities: Set[SEQ]) -&gt; Set[SEQ]\n</code></pre> <p>Remove superset delta sequences.</p> <p>Parameters:</p> Name Type Description Default <code>infinities</code> <code>Set[SEQ]</code> <p>set of delta sequences causing infinity.</p> required <p>Returns:</p> Type Description <code>Set[SEQ]</code> <p>A list where all longer sequences, whose pattern is covered by some shorter sequence, are removed.</p>"},{"location":"choice/#pymwp.choice.Choices.vect_contains","title":"vect_contains  <code>staticmethod</code>","text":"<pre><code>vect_contains(a: VECT, b: VECT) -&gt; bool\n</code></pre> <p>Check if A allows making all choices of B.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>VECT</code> <p>first vector.</p> required <code>b</code> <code>VECT</code> <p>second vector.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if A contains B, and False otherwise.</p>"},{"location":"choice/#pymwp.choice.Choices.vect_intersection","title":"vect_intersection  <code>staticmethod</code>","text":"<pre><code>vect_intersection(a: VECT, b: VECT) -&gt; Optional[VECT]\n</code></pre> <p>Intersection of two vectors.</p> <p>The intersection is the maximal choice at each index, permitted by both vectors A and B. The intersection is empty if, at some index, no choice exists.</p> Example <p>Let a=<code>((0,1),(0,2))</code>, b=<code>((1,),(1,2))</code>, and c=<code>((1,),(1,))</code>.</p> <ul> <li>The intersection of a&amp;b is <code>((1,),(2,))</code>.</li> <li>The intersection of a&amp;c is None.</li> <li>The intersection of b&amp;c is <code>((1,),(1,))</code>.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>VECT</code> <p>first vector.</p> required <code>b</code> <code>VECT</code> <p>second vector.</p> required <p>Returns:</p> Type Description <code>Optional[VECT]</code> <p>A new vector that is the intersection of A and B; <code>None</code> when the intersection is empty.</p>"},{"location":"choice/#pymwp.choice.Choices.vect_new","title":"vect_new  <code>staticmethod</code>","text":"<pre><code>vect_new(vectors: Set[VECT], vector: VECT) -&gt; bool\n</code></pre> <p>Determines if a vector is distinct from all existing vectors.</p> <p>Parameters:</p> Name Type Description Default <code>vectors</code> <code>Set[VECT]</code> <p>a set of known vectors.</p> required <code>vector</code> <code>VECT</code> <p>vector to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if vector does not occur in vectors.</p>"},{"location":"choice/#pymwp.choice.Choices.vect_rm","title":"vect_rm  <code>staticmethod</code>","text":"<pre><code>vect_rm(vectors: Set[VECT], vector: VECT) -&gt; None\n</code></pre> <p>Remove from vectors those that are contained by vector.</p> <p>Parameters:</p> Name Type Description Default <code>vectors</code> <code>Set[VECT]</code> <p>a set of vectors.</p> required <code>vector</code> <code>VECT</code> <p>vector compare against.</p> required"},{"location":"constants/","title":"constants.py","text":"<p>Custom types and analysis constants.</p>"},{"location":"constants/#pymwp.constants.B_TRIPLE","title":"B_TRIPLE  <code>module-attribute</code>","text":"<pre><code>B_TRIPLE = Tuple[Tuple[str, ...], Tuple[str, ...], Tuple[str, ...]]\n</code></pre> <p>mwp-bound triple with three variable lists.</p>"},{"location":"constants/#pymwp.constants.CHOICES","title":"CHOICES  <code>module-attribute</code>","text":"<pre><code>CHOICES = List[List[List[int]]]\n</code></pre> <p>A list of choice vectors.</p>"},{"location":"constants/#pymwp.constants.COM_RES","title":"COM_RES  <code>module-attribute</code>","text":"<pre><code>COM_RES = Tuple[int, 'RelationList', bool]\n</code></pre> <p>Command analysis result type.</p>"},{"location":"constants/#pymwp.constants.DELTA","title":"DELTA  <code>module-attribute</code>","text":"<pre><code>DELTA = Tuple[int, int]\n</code></pre> <p>Delta is a tuple of two integers: (choice, index).</p>"},{"location":"constants/#pymwp.constants.DELTAS","title":"DELTAS  <code>module-attribute</code>","text":"<pre><code>DELTAS = TypeVar('DELTAS', bound=DELTA)\n</code></pre> <p>A TypeVar for deltas.</p>"},{"location":"constants/#pymwp.constants.MATRIX","title":"MATRIX  <code>module-attribute</code>","text":"<pre><code>MATRIX = List[List['Polynomial']]\n</code></pre> <p>mwp-matrix type.</p>"},{"location":"constants/#pymwp.constants.NODE","title":"NODE  <code>module-attribute</code>","text":"<pre><code>NODE = Tuple[DELTA, ...]\n</code></pre> <p>A tuple of deltas.</p>"},{"location":"constants/#pymwp.constants.SEQ","title":"SEQ  <code>module-attribute</code>","text":"<pre><code>SEQ = Tuple[DELTA, ...]\n</code></pre> <p>A tuple of deltas.</p>"},{"location":"constants/#pymwp.constants.VECT","title":"VECT  <code>module-attribute</code>","text":"<pre><code>VECT = Tuple[Tuple[int, ...], ...]\n</code></pre> <p>A vector is a tuple of integer-tuples.</p>"},{"location":"constants/#pymwp.constants.Comparison","title":"Comparison","text":"<p>               Bases: <code>IntEnum</code></p> <p>Represent result of delta comparison.</p>"},{"location":"constants/#pymwp.constants.SetInclusion","title":"SetInclusion","text":"<p>               Bases: <code>IntEnum</code></p> <p>Represent result of monomial inclusion.</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing-guidelines","title":"Contributing Guidelines","text":"<p>This guide explains how to set up a development environment, how to make various changes, including documentation and deployments. It also explains the relevant workflows for various development tasks.</p>"},{"location":"contributing/#environment-setup","title":"Environment Setup","text":"<ol> <li> <p>Create a Python virtual environment</p> <p>Typically, this requires:</p> <pre><code>python3 -m venv venv\nsource venv/bin/activate\n</code></pre> <p>For additional details and troubleshooting, see Python documentation on virtual environments.</p> </li> <li> <p>Install required development dependencies</p> <pre><code>python -m pip install -r requirements-dev.txt\n</code></pre> </li> </ol>"},{"location":"contributing/#source-code-changes","title":"Source Code Changes","text":"Debugging Changes <p>The source code is in <code>pymwp</code> directory. When running from source, use the command:</p> <pre><code>python3 -m pymwp [args]\n</code></pre> Checking Changes <p>Any changes to source code must pass lint and unit tests. These are checked automatically for PRs and commits to main branch. </p> <pre><code>make pre-commit   # check everything\nmake test         # check unit tests only\nmake lint         # check code style only\n</code></pre> <ul> <li> <p>This project uses flake8 for linting.   You can use it to check specific files, or run against all Python source files, by specifying a path.</p> </li> <li> <p>Unit tests are in <code>tests</code> directory. You can run unit tests on specific files or the entire source.   See pytest documentation for more details.</p> </li> <li> <p>There are additional interesting performance checks, e.g., benchmarking and profiling.   These are documented in utilities.</p> </li> </ul> <p>Relevant workflows</p> <p> checks code changes using the latest Python runtime.</p> <p> checks code changes against various Python runtimes.              </p>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Setting up the code environment and dependencies, also includes the setup for pymwp docs. The documentation is built with mkdocs.</p> <p>If you want to build and run the documentation website locally, run:</p> <pre><code>python -m pip install -r requirements-doc.txt\nmkdocs serve\n</code></pre> <p>This will launch a web server, by default at port 8000 (<code>https://localhost:8000</code>). Then it is possible to preview documentation changes locally in browser.</p> <p>Once those changes are satisfactory, commits to main branch will automatically deploy the documentation changes.</p> <p>Relevant workflows</p> <p> builds and pushes documentation to gh-pages branch.</p> <p> deploys gh-pages branch. </p>"},{"location":"contributing/#code-releases","title":"Code Releases","text":"Tagging a commit in <code>main</code> branch will automatically kick off a deployment and release, for all configured distribution channels. <p>Python Package Index</p> <ul> <li>Builds and uploads a distribution version of the software.</li> <li>The meta data for PyPI release is defined in <code>setup.py</code></li> </ul> <p>GitHub Release</p> <ul> <li>Creates a release with relevant release assets.</li> <li>These assets are defined in the publish-workflow.</li> <li>Release details can be edited manually and after release.</li> </ul> <p>Zenodo archival deposit</p> <ul> <li>Following GH release event, Zenodo webhook will generate a comparable archival release.</li> <li>Pre-set meta data for Zenodo deposit is defined in <code>.zenodo.json</code>.</li> <li>See deposit meta data docs for possible options.</li> </ul> <p>Relevant workflows</p> <p> handles all release and deployment tasks.</p>"},{"location":"delta_graphs/","title":"delta_graphs.py","text":"<pre><code>from pymwp import DeltaGraph\n</code></pre>"},{"location":"delta_graphs/#pymwp.delta_graphs.DeltaGraph","title":"DeltaGraph","text":"<pre><code>DeltaGraph(*init_nodes: Optional[Union[Monomial, NODE]], degree: int = 3)\n</code></pre> <p>Delta Graph is a dictionary representing a weighted graph of tuples of deltas (also referenced here as a monomial_list, a list of Monomials without its scalar). We will often refer to tuple of deltas as simple node, but a node with length!</p> <p>Nodes are \"sorted\" by this length in order to be compared by chunks of same size.</p> <p>Weight of edge represents the index where the nodes differ.</p> <p>We use tuple because we want them to be hashable (as key in dictionary).</p> Example <pre><code>                      \u2193\nn1 = ((0,1), (0,2), (0,3), (0,4))\nn2 = ((0,1), (0,2), (1,3), (0,4))\n</code></pre> <p>in our graph will have:</p> <pre><code>n1 &lt;---- 3 ----&gt; n2\n</code></pre> <p>or</p> <pre><code>size = 4   \u2193\ngraph_dict[4][n1][n2] = 3\n</code></pre> <p>The graph is symmetric:</p> <pre><code>graph_dict[4][n2][n1] = 3\n</code></pre> <p>This representation will help us simplify the evaluation by removing redundant/irrelevant choices/paths.</p> <p>Attributes:</p> Name Type Description <code>graph_dict</code> <code>dict</code> <p>Dictionary of nodes.</p> <code>degree</code> <code>int</code> <p>Graph degree.</p> <p>Create a Delta Graph.</p> <p>Parameters:</p> Name Type Description Default <code>*init_nodes</code> <code>Optional[Union[Monomial, NODE]]</code> <p>Initial list of monomials or nodes.</p> <code>()</code> <code>degree</code> <code>int</code> <p>Degree of a full node.</p> <code>3</code> Example <p>Create an empty delta graph</p> <pre><code>dg = DeltaGraph()\n</code></pre> <p>Create delta graph with some initial nodes from monomials.</p> <pre><code>dg = DeltaGraph(mono1, mono2)\n</code></pre>"},{"location":"delta_graphs/#pymwp.delta_graphs.DeltaGraph.from_monomial","title":"from_monomial","text":"<pre><code>from_monomial(monomial: Monomial) -&gt; None\n</code></pre> <p>Add monomial's deltas to the delta graph.</p> <p>Parameters:</p> Name Type Description Default <code>monomial</code> <code>Monomial</code> <p>monomial</p> required"},{"location":"delta_graphs/#pymwp.delta_graphs.DeltaGraph.fusion","title":"fusion","text":"<pre><code>fusion() -&gt; None\n</code></pre> <p>Eliminates cliques of same label in a delta graph.</p> Example <pre><code>m1 = ((0, 1), (0, 2))\nm2 = ((0, 1), (1, 2))\nm3 = ((0, 1), (2, 2), (0, 3))\nm4 = ((0, 1), (2, 2), (1, 3))\nm5 = ((0, 1), (2, 2), (2, 3))\n\nDelta graph:\n\n  m1 -- 2 -- m2\n  m3 -- 3 -- m4\n   \u27cd         |\n      3      3\n        \u27cd    |\n          \u27cd  |\n            m5\n\nLooks for cliques (size default 3) at each index.\n=&gt; Graph will simplify to: ((0,1)).\n</code></pre>"},{"location":"delta_graphs/#pymwp.delta_graphs.DeltaGraph.insert_edge","title":"insert_edge","text":"<pre><code>insert_edge(node1: NODE, node2: NODE, label: int) -&gt; None\n</code></pre> <p>Add an edge of label <code>label</code> between <code>node1</code> and <code>node2</code> If one node does not exist, it's created</p> <p>Symmetry is also added in the graph.</p> <p>Parameters:</p> Name Type Description Default <code>node1</code> <code>NODE</code> <p>first node</p> required <code>node2</code> <code>NODE</code> <p>second node</p> required <code>label</code> <code>int</code> <p>label over the edge</p> required"},{"location":"delta_graphs/#pymwp.delta_graphs.DeltaGraph.insert_node","title":"insert_node","text":"<pre><code>insert_node(node: NODE) -&gt; None\n</code></pre> <p>Insert a node into the graph.</p> <p>If a node is already in the graph do nothing. Else compare it with all nodes of same size with <code>node_diff</code>.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>NODE</code> <p>tuple to insert in the graph</p> required"},{"location":"delta_graphs/#pymwp.delta_graphs.DeltaGraph.is_full","title":"is_full","text":"<pre><code>is_full(node: NODE, size: int, index: int) -&gt; bool\n</code></pre> <p>Check for cliques of same label.</p> Example <pre><code>n3 = ((0, 1), (2, 2), (0, 3))\nn4 = ((0, 1), (2, 2), (1, 3))\nn5 = ((0, 1), (2, 2), (2, 3))\n\nnode = n4\nsize = 3\nindex = 3\ndegree = 3\n\nn3 -- 3 -- n4\n \u27cd         |\n    3       3\n      \u27cd    |\n        \u27cd  |\n          n5\n\nreturn True\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>NODE</code> <p>check for clique around that graph node.</p> required <code>size</code> <code>int</code> <p>size of nodes or graph \"level\".</p> required <code>index</code> <code>int</code> <p>index where to find clique.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if there is a clique.</p>"},{"location":"delta_graphs/#pymwp.delta_graphs.DeltaGraph.node_diff","title":"node_diff  <code>staticmethod</code>","text":"<pre><code>node_diff(\n    node1: NODE, node2: NODE, index: Optional[int] = None\n) -&gt; Tuple[bool, int]\n</code></pre> <p>Compares two nodes of the same length.</p> <p>The return value is a tuple representing the result of comparison (boolean) and an index.</p> <p>The result is True, if and only if both lists differ only on one element regarding the same index. The second return value is the index of the corresponding delta.</p> <p>Parameters:</p> Name Type Description Default <code>node1</code> <code>NODE</code> <p>first monomial list</p> required <code>node2</code> <code>NODE</code> <p>second monomial list</p> required <code>index</code> <code>Optional[int]</code> <p>index with to check number of diff</p> <code>None</code> <p>Returns:</p> Name Type Description <code>diff</code> <code>bool</code> <p>boolean True if the lists differ of one element</p> <code>i</code> <code>int</code> <p>the index of the delta which differs</p>"},{"location":"delta_graphs/#pymwp.delta_graphs.DeltaGraph.remove_index","title":"remove_index  <code>staticmethod</code>","text":"<pre><code>remove_index(node: NODE, index: int) -&gt; NODE\n</code></pre> <p>Remove delta with given index.</p> Example <pre><code>remove index 4:\n((0, 2), (1, 3), (2, 4))  -&gt;  ((0, 2), (1, 3))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>NODE</code> <p>monomial list</p> required <code>index</code> <code>int</code> <p>index to remove</p> required <p>Returns:</p> Type Description <code>NODE</code> <p>a new tuple without deltas with index <code>index</code></p>"},{"location":"delta_graphs/#pymwp.delta_graphs.DeltaGraph.remove_node","title":"remove_node","text":"<pre><code>remove_node(node: NODE, index: int) -&gt; None\n</code></pre> <p>Remove given node and neighbors connected with same label.</p> <p>Also removes edges/labels connected to the node (they no longer exist).</p>"},{"location":"demo/","title":"Demo","text":"<p>This demo allows running pymwp analysis on example programs on the web.   Refer to the tool user guide for detailed explanations of how to interpret the results.</p> <p></p> Select example to analyze:  Loading demo..."},{"location":"examples/","title":"Examples","text":"<p>pymwp analyzes programs written in C language. The project repository <code>c_files</code> directory contains many examples.</p>"},{"location":"examples/#program-categories","title":"Program CategoriesDemo","text":"<p> BasicsPrograms performing operations that correspond to simple derivation trees.</p> <p> InfinitePrograms that are assigned matrices that always contain infinite coefficients, no matter the choices.</p> <p> Not InfinitePrograms that are assigned matrices that do not always contain infinite coefficients.</p> <p> Original PaperExamples taken from or inspired by paper \"A Flow Calculus of mwp-Bounds for Complexity Analysis\"\u2197.</p> <p> Implementation PaperExamples from \"mwp-Analysis Improvement and Implementation: Realizing Implicit Computational Complexity\"\u2197.</p> <p> Tool paperExamples from \"pymwp: A Static Analyzer Determining Polynomial Growth Bounds\"\u2197.</p> <p> OtherOther programs of interest.</p> <p>Try the demo to analyze these programs online.</p> <p>Go to Demo</p>"},{"location":"examples/#list-of-input-program-examples","title":"List of Input Program Examples","text":"Category File name Description Basics <code>assign_expression.c</code> assign result of binary operation to variable <code>assign_variable.c</code> assign using variable <code>if.c</code> assignment within conditional statement <code>if_else.c</code> conditional statement with <code>if</code> and <code>else</code> <code>inline_variable.c</code> local variable declaration <code>while_1.c</code> while loop with assignment <code>while_2.c</code> while loop with binary operation <code>while_3.c</code> non-infinite while loop with three variables <code>while_if.c</code> while loop followed by <code>if...else</code> Implementation Paper<sup>1</sup> <code>example8.c</code> An illustration of the sum of two choices. <code>example14.c</code> Examples with function call <code>example16.c</code> Example of an inlined function call Infinite <code>exponent_1.c</code> exponential computation <code>exponent_2.c</code> alternative exponential computation <code>infinite_2.c</code> <code>while</code> loop with binary operations <code>infinite_3.c</code> <code>while</code> loop and <code>if</code> statement <code>infinite_4.c</code> <code>while</code> loop <code>infinite_5.c</code> <code>while</code> loop and <code>if</code> statement <code>infinite_6.c</code> <code>if...else</code> and <code>while</code> loop <code>infinite_7.c</code> 2 <code>while</code> loops and <code>if</code> <code>infinite_8.c</code> <code>while</code> with nested <code>if...else</code> and other conditionals Not Infinite <code>notinfinite_2.c</code> binary operations <code>notinfinite_3.c</code> <code>if</code> and <code>while</code> loop <code>notinfinite_4.c</code> <code>if</code> and <code>while</code> loop <code>notinfinite_5.c</code> <code>if</code> and <code>while</code> loop <code>notinfinite_6.c</code> <code>if...else</code> and <code>while</code> loop <code>notinfinite_7.c</code> 2 <code>while</code> loops and <code>if</code> <code>notinfinite_8.c</code> <code>while</code> with nested <code>if...else</code> and other conditionals Original Paper<sup>2</sup> <code>example3_1_a.c</code> Analysis of two commands <code>example3_1_b.c</code> Analysis of two commands <code>example3_1_c.c</code> Binary operation inside <code>while</code> loop <code>example3_1_d.c</code> Two variables and a <code>while</code> loop <code>example3_2.c</code> Three variables and <code>while</code> loop <code>example3_4.c</code> Iteration with 5 variables, using while (W) rule <code>example3_4_loop.c</code> Iteration with 5 variables, using loop (L) rule <code>example3_5.c</code> Iteration with 3 variables, where some derivation paths fail <code>example5_1.c</code> Adding two variables <code>example7_10.c</code> program with <code>if...else</code> and 3 variables <code>example7_11.c</code> Binary operations with 4 variables Other <code>dense.c</code> Produces a 3 x 3 dense matrix. <code>dense_loop.c</code> Produces a dense matrix with infinite coefficients in it. <code>explosion.c</code> Explosion of the number of cases <code>gcd.c</code> Greatest common divisor by subtraction <code>long.c</code> Longer program with multiple loops and nested statements <code>simplified_dense.c</code> Simplified dense matrix <code>xnu.c</code> SPEC CPU2006   hmmer/src/masks.c XNU function <code>xnu_simple.c</code> XnuSimple example from DOI: 10.1007/s10817-016-9402-4 Tool paper<sup>3</sup><sup>5</sup> <code>tool_ex_1.c</code> Sect 1. Example 1 from pymwp tool paper <code>tool_ex_2.c</code> Sect 2.2 Example 2 from pymwp tool paper <code>tool_ex_3.c</code> Sect 2.2 Example 3 from pymwp tool paper <code>t19.c_c4b</code> Table 1: t19.c from Carbonneaux et al. 2015<sup>4</sup> <code>t20.c_c4b</code> Table 1: t20.c from Carbonneaux et al. 2015<sup>4</sup> <code>t47.c_c4b</code> Table 1: t47.c from Carbonneaux et al. 2015<sup>4</sup> <ol> <li> <p>\"mwp-Analysis Improvement and Implementation: Realizing Implicit Computational Complexity\" https://doi.org/10.4230/LIPIcs.FSCD.2022.26 \u21a9</p> </li> <li> <p>\"A Flow Calculus of mwp-Bounds for Complexity Analysis\" https://doi.org/10.1145/1555746.1555752 \u21a9</p> </li> <li> <p>\"pymwp: A Static Analyzer Determining Polynomial Growth Bounds\" https://doi.org/10.1007/978-3-031-45332-8_14 \u21a9</p> </li> <li> <p>Syntax of these examples is adjusted to semantically equivalent statements supported by pymwp, e.g., unary <code>x++</code> must be expressed as <code>x = x + 1</code>.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>Tool paper Sect 4.2 Example 4 is same as <code>infinite/infinite_3.c</code> \u21a9</p> </li> </ol>"},{"location":"features/","title":"Supported C Language Features","text":"<p>The table below summarizes the supported C language features pymwp can analyze.  </p> <p>Note on C file parsing</p> <p>pymwp uses pycparser to process the C input file. Any limitation of pycparser is also a limitation in pymwp. From pycparser website: \"pycparser aims to support the full C99 language (according to the standard ISO/IEC 9899). Some features from C11 are also supported.\"</p> <p>What happens if the C program contains unsupported syntax? </p> <ul> <li>By default, the analysis skips unsupported statements and raises a warning.</li> <li>In strict mode (<code>--strict</code>), analysis skips whole constructs (\"programs\") that contain unsupported syntax. </li> </ul> <p>The strict mode is sound, but not very informative in case of an unsupported program. The default handling is more useful for developing the analysis.</p> Legend <p>\ud83d\udfe9 \u00a0 ready \u2014 fully implemented and ready to use</p> <p>\ud83d\udfe7 \u00a0 in progress \u2014 implementation in progress, but not ready</p> <p>\u2b1c \u00a0 planned \u2014 implementation is in a planning stage</p> Description State Example Basic data types Integer types (incl. <code>signed</code>, <code>unsigned</code>) \ud83d\udfe9 <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code> Floating point types \ud83d\udfe9 <code>float</code>, <code>double</code>, <code>long double</code> Declarations Variable declarations \ud83d\udfe9 <code>int x;</code> Constant declarations \ud83d\udfe9 <code>const int x;</code> Assignment \ud83d\udfe9 <code>x = y</code> Compound assignment \u2b1c <code>x += 1</code> Arithmetic operations Unary operations (\\(+, -, ++,--,!\\), <code>sizeof</code>) \ud83d\udfe9 <code>++x</code>, <code>x--</code>, <code>sizeof(x)</code> Binary operations (\\(+, \\times, -\\))<sup>1</sup> \ud83d\udfe9 <code>x = y + z</code> N-ary/nested operation \u2b1c <code>y + (++z) * w</code> Casting (limited support) \ud83d\udfe7 <code>x = (int)x</code> Conditional statements if statement \ud83d\udfe9 <code>if(x &gt; 0) { ... }</code> if-else statement \ud83d\udfe9 <code>if(x &gt; 0) { ... } else { ... }</code> Nested conditional \ud83d\udfe9 <code>if(x &gt; 0) { if (y &gt; 0) { ... } }</code> Repetition statements <code>while</code> loop<sup>2</sup> \ud83d\udfe9 <code>while(x &lt; 20) { ... }</code> <code>for</code> loop<sup>2</sup> \ud83d\udfe9 <code>for (i = 0; i &lt; x; ++i) { ... }</code> Jump statements  (excl. <code>goto</code>) \ud83d\udfe9 <code>break</code>, <code>continue</code>, <code>return x</code> Functions \ud83d\udfe7 <code>foo(arg1, arg2)</code> Pointers (<code>*</code>, <code>&amp;</code> address-of) \u2b1c Arrays \u2b1c Header files inclusion \ud83d\udfe9 <code>#include &lt;stdio.h&gt;</code> Comments (single-line, delimited) \ud83d\udfe9 <code>// comment</code>, <code>/* comment */</code> assume and assert macros \ud83d\udfe9 <code>assert (x == y)</code> <ol> <li> <p>Binary operands must be variables or constants.\u00a0\u21a9</p> </li> <li> <p>Loop handling is very important in the mwp calculus.    A C language looping construct converts to a bounded or unbounded loop.   A bounded loop must have form \"run <code>X</code> times\" and the guard variable <code>X</code> cannot occur in body.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"file_io/","title":"file_io.py","text":"<p>Helper methods for performing disk I/O operation on analysis results.</p> <p>To generate file name for storing results:</p> <pre><code>from pymwp.file_io import default_file_out\n</code></pre> <p>To save or restore results as JSON:</p> <pre><code>from pymwp.file_io import save_result, load_result\n</code></pre>"},{"location":"file_io/#pymwp.file_io.default_file_out","title":"default_file_out","text":"<pre><code>default_file_out(input_file: str) -&gt; str\n</code></pre> <p>Generates default output file.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>input filename (with or without path).</p> required <p>Returns:</p> Type Description <code>str</code> <p>Generated output filename with path.</p>"},{"location":"file_io/#pymwp.file_io.del_comments","title":"del_comments","text":"<pre><code>del_comments(text: str) -&gt; str\n</code></pre> <p>Remove C-style comments. Thanks to https://stackoverflow.com/a/241506</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>C code fragment</p> required <p>Returns:</p> Type Description <code>str</code> <p>Text without comments.</p>"},{"location":"file_io/#pymwp.file_io.load_result","title":"load_result","text":"<pre><code>load_result(file_name: str) -&gt; Result\n</code></pre> <p>Load previous analysis result from file.</p> <p>This method is the reverse of <code>save_result</code> and assumes the input matches the output of that method.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>File to read.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>if <code>file_name</code> does not exist or cannot be read.</p> <p>Returns:</p> Type Description <code>Result</code> <p>Parsed result from file.</p>"},{"location":"file_io/#pymwp.file_io.loc","title":"loc","text":"<pre><code>loc(input_file: str) -&gt; int\n</code></pre> <p>Get number of lines is a file.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Path to input file.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of non-empty lines in input file.</p>"},{"location":"file_io/#pymwp.file_io.save_result","title":"save_result","text":"<pre><code>save_result(file_name: str, analysis_result: Result) -&gt; None\n</code></pre> <p>Save analysis result to file as JSON.</p> <p>Expected behavior:</p> <ul> <li>if path to output file does not exist it will be created</li> <li>if output file does not exist it will be created</li> <li>if output file exists it will be overwritten</li> </ul> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Filename where to write.</p> required <code>analysis_result</code> <code>Result</code> <p>Result object.</p> required"},{"location":"matrix/","title":"matrix.py","text":"<p>Helper methods for working with matrices.</p> <p>To create matrices:</p> <pre><code>from pymwp.matrix import init_matrix, identity_matrix\n</code></pre> <p>To compute matrix sum and product:</p> <pre><code>from pymwp.matrix import matrix_prod, matrix_sum\n</code></pre> <p>Other utility methods:</p> <pre><code>from pymwp.matrix import equals, fixpoint, show, resize, encode, decode\n</code></pre>"},{"location":"matrix/#pymwp.matrix.decode","title":"decode","text":"<pre><code>decode(matrix: List[List[List[dict]]]) -&gt; MATRIX\n</code></pre> <p>Converts matrix of dictionaries to a matrix of polynomials.</p> <p>Primary use case of this function is for restoring a matrix of  polynomials from a file (assuming encode  was used to generate that file).</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>List[List[List[dict]]]</code> <p>matrix to decode</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the matrix value is not iterable</p> <code>AttributeError</code> <p>If the matrix elements are not valid encoded polynomials.</p> <p>Returns:</p> Type Description <code>MATRIX</code> <p>Decoded matrix of polynomials.</p>"},{"location":"matrix/#pymwp.matrix.encode","title":"encode","text":"<pre><code>encode(matrix: MATRIX) -&gt; List[List[List[dict]]]\n</code></pre> <p>Converts a matrix of polynomials to a matrix of dictionaries.</p> <p>This function is useful when preparing to write a matrix of polynomials to a file. The same matrix can later be restored using matrix decode.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>MATRIX</code> <p>matrix to encode</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the matrix does not contain polynomials.</p> <p>Returns:</p> Type Description <code>List[List[List[dict]]]</code> <p>Encoded matrix.</p>"},{"location":"matrix/#pymwp.matrix.equals","title":"equals","text":"<pre><code>equals(matrix1: MATRIX, matrix2: MATRIX) -&gt; bool\n</code></pre> <p>Determine if two matrices are equal.</p> <p>This function performs element-wise equality comparisons on values of two matrices. The two matrices must be the same size. For any two matrices of different size the result is always <code>False</code>.</p> <p>This function can evaluate values that are comparable by equals <code>==</code> operator.</p> <p>Parameters:</p> Name Type Description Default <code>matrix1</code> <code>MATRIX</code> <p>First matrix.</p> required <code>matrix2</code> <code>MATRIX</code> <p>Second matrix.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the matrix value is not iterable.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if matrices are equal element-wise and <code>False</code> otherwise.</p>"},{"location":"matrix/#pymwp.matrix.fixpoint","title":"fixpoint","text":"<pre><code>fixpoint(matrix: MATRIX) -&gt; MATRIX\n</code></pre> <p>Computes the star operation \\(1 + M + M^2 + M^3 + \u2026\\)</p> <p>This function assumes provided input is a square matrix.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>MATRIX</code> <p>Matrix for which to compute fixpoint.</p> required <p>Returns:</p> Type Description <code>MATRIX</code> <p>\\(M^*\\)</p>"},{"location":"matrix/#pymwp.matrix.identity_matrix","title":"identity_matrix","text":"<pre><code>identity_matrix(size: int) -&gt; List[list]\n</code></pre> <p>Create identity matrix of specified size.</p> Example <p>Generate 5 x 5 size identity matrix:</p> <pre><code>identity_matrix(5)\n</code></pre> <p>Generates:</p> <pre><code>[[m, o, o, o, o],\n [o, m, o, o, o],\n [o, o, m, o, o],\n [o, o, o, m, o],\n [o, o, o, o, m]]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>matrix size</p> required <p>Returns:</p> Type Description <code>List[list]</code> <p>New identity matrix.</p>"},{"location":"matrix/#pymwp.matrix.init_matrix","title":"init_matrix","text":"<pre><code>init_matrix(size: int, init_value: Optional[Any] = None) -&gt; List[list]\n</code></pre> <p>Create empty matrix of specified size.</p> Example <p>Generate 5 x 5 size zero-matrix.</p> <pre><code>init_matrix(5)\n</code></pre> <p>Generates:</p> <pre><code>[[o, o, o, o, o],\n [o, o, o, o, o],\n [o, o, o, o, o],\n [o, o, o, o, o],\n [o, o, o, o, o]]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>matrix size.</p> required <code>init_value</code> <code>Optional[Any]</code> <p>value to place at each index. If not provided, will default to 0-polynomial.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[list]</code> <p>Initialized matrix.</p>"},{"location":"matrix/#pymwp.matrix.matrix_prod","title":"matrix_prod","text":"<pre><code>matrix_prod(matrix1: MATRIX, matrix2: MATRIX) -&gt; MATRIX\n</code></pre> <p>Compute the product of two polynomial matrices.</p> <p>Parameters:</p> Name Type Description Default <code>matrix1</code> <code>MATRIX</code> <p>First polynomial matrix.</p> required <code>matrix2</code> <code>MATRIX</code> <p>Second polynomial matrix.</p> required <p>Returns:</p> Type Description <code>MATRIX</code> <p>A new matrix that represents the product of the two inputs.</p>"},{"location":"matrix/#pymwp.matrix.matrix_sum","title":"matrix_sum","text":"<pre><code>matrix_sum(matrix1: MATRIX, matrix2: MATRIX) -&gt; MATRIX\n</code></pre> <p>Compute the sum of two polynomial matrices.</p> <p>Parameters:</p> Name Type Description Default <code>matrix1</code> <code>MATRIX</code> <p>First polynomial matrix.</p> required <code>matrix2</code> <code>MATRIX</code> <p>Second polynomial matrix.</p> required <p>Returns:</p> Type Description <code>MATRIX</code> <p>A new matrix that represents the sum of the two inputs.</p>"},{"location":"matrix/#pymwp.matrix.resize","title":"resize","text":"<pre><code>resize(matrix: MATRIX, new_size: int) -&gt; MATRIX\n</code></pre> <p>Create a new matrix of polynomials of specified size.</p> <p>The resized matrix is initialized as an identity matrix then filled with values from the original matrix.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>MATRIX</code> <p>original matrix</p> required <code>new_size</code> <code>int</code> <p>width/height of new matrix</p> required <p>Returns:</p> Type Description <code>MATRIX</code> <p>New matrix of specified size, filled with values from the original matrix.</p>"},{"location":"matrix/#pymwp.matrix.show","title":"show","text":"<pre><code>show(\n    matrix: MATRIX,\n    prefix: str = None,\n    postfix: str = None,\n    fmt: Callable[[Any], str] = None,\n) -&gt; None\n</code></pre> <p>Pretty print a matrix at the screen.</p> <p>Using the keyword arguments to display additional text before or after the matrix.</p> Example Matrix onlyMatrix with text <pre><code>my_matrix = identity_matrix(3)\nshow(my_matrix)\n</code></pre> <p>Displays:</p> <pre><code>+m  +o  +o\n+o  +m  +o\n+o  +o  +m\n</code></pre> <pre><code>my_matrix = identity_matrix(3)\nheader = ' x1  x2  x3'\nshow(my_matrix, prefix=header)\n</code></pre> <p>Displays:</p> <pre><code>x1  x2  x3\n+m  +o  +o\n+o  +m  +o\n+o  +o  +m\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>MATRIX</code> <p>The matrix to display.</p> required <code>prefix</code> <code>str</code> <p>display some text before displaying matrix</p> <code>None</code> <code>postfix</code> <code>str</code> <p>display some text after displaying matrix</p> <code>None</code> <code>fmt</code> <code>Callable[[Any], str]</code> <p>Optional element formatter function.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the matrix is not iterable (type list of lists)</p>"},{"location":"modules/","title":"Technical Introduction","text":"<p>At a high-level, pymwp reads a C file and produces an analysis result.</p> <p></p> <p>Fig. 1: pymwp workflow</p> <p>Under the hood, pymwp is built from various modules. Each module has a specific role. For example, <code>Analysis</code> runs program analysis (i.e., the intermediate steps between parser and output in Fig. 1);  the <code>matrix</code> module contains matrix utilities, the <code>parser</code> is the front-end, etc.</p> <p>This documentation section explains the internal behaviors of these building blocks. Understanding these modules becomes relevant when importing pymwp in scripts.</p>"},{"location":"modules/#scripting-examples","title":"Scripting Examples","text":""},{"location":"modules/#reusing-analysis-output","title":"Reusing analysis output","text":"<p>This scenario describes reusing the pymwp analysis result in further computation.</p> <ul> <li>An analysis run returns a <code>Result</code> object.</li> <li>Function <code>get_func(...)</code> returns the analysis result of the specified function.</li> </ul> Python scriptAnalysis input (if.c)Terminal output <pre><code>from pymwp import Analysis, Parser\nfrom pprint import pprint\n\n# path to file to analyze\nfile = 'c_files/basics/if.c'\n\n# parses a C-langugage file using pycparser\nast = Parser.parse(file, use_cpp=True, cpp_path='gcc')\n\n# run analysis, then access result for main function\nresult = Analysis.run(ast, fin=True, no_save=True).get_func('main')\n\n# do something with the analysis result\n# display analysis result and collected data\npprint(result.to_dict())\n</code></pre> <pre><code>// contents of if.c\nint main(int x, int y){\n    if (0) {y = x;}\n}\n</code></pre> <pre><code>{'bound': {'x': 'x;;', 'y': 'x,y;;'},\n'choices': [[[0, 1, 2]]],\n'end_time': 1725498245384529000,\n'index': 1,\n'inf_flows': None,\n'infinity': False,\n'name': 'foo',\n'relation': {'matrix': [[[{'deltas': [], 'scalar': 'm'}],\n                         [{'deltas': [], 'scalar': 'm'}]],\n                        [[{'deltas': [], 'scalar': 'o'}],\n                         [{'deltas': [], 'scalar': 'm'}]]]},\n'start_time': 1725498245383927000,\n'variables': ['x', 'y']}\n</code></pre>"},{"location":"modules/#build-with-analysis-modules","title":"Build with analysis modules","text":"<p>Working directly with the internal modules allows customizing the analysis behavior and building related analyses.</p> Python scriptTerminal output <pre><code>from pymwp import Polynomial, Monomial\nfrom pymwp.matrix import identity_matrix, show\n\nmatrix = identity_matrix(3)\nmatrix[0][1] = Polynomial('m')\nmatrix[1][1] = Polynomial('w')\nmatrix[2][1] = Polynomial(Monomial('p', (0, 0), (1, 1)))\n\nshow(matrix)\n</code></pre> <pre><code>[' +m', ' +m', ' +o']\n[' +o', ' +w', ' +o']\n[' +o', ' +p.delta(0,0).delta(1,1)', ' +m']\n</code></pre>"},{"location":"monomial/","title":"monomial.py","text":"<pre><code>from pymwp import Monomial\n</code></pre>"},{"location":"monomial/#pymwp.monomial.Monomial","title":"Monomial","text":"<pre><code>Monomial(\n    scalar: str = UNIT_MWP,\n    deltas: Optional[Union[List[DELTA], DELTA]] = None,\n    *args: Optional[DELTA]\n)\n</code></pre> <p>A monomial is a pair made of:</p> <ol> <li><code>scalar</code> - a value in the semi-ring</li> <li>a sorted list of <code>deltas</code>, where an index occurs at most once.</li> </ol> <p>Deltas are coded as pairs \\((i,j)\\) with:</p> <ul> <li>\\(i\\) the value and</li> <li>\\(j\\) the index in the domain (infinite product)</li> </ul> <p>We will have that \\((i,j)\\) will be equal to the unit of the semi-ring iff the \\(j^{th}\\) input is equal to \\(i\\) (so, the \\(j^{th}\\) choice is \\(i\\)).</p> <p>We will make the assumption that the deltas of delta is sorted and no two deltas can have the same index.</p> <p>Attributes:</p> Name Type Description <code>scalar</code> <code>str</code> <p>Monomial scalar.</p> <code>deltas</code> <code>List[DELTA]</code> <p>List of deltas.</p> <p>Create a monomial.</p> Example <p>Create a monomial.</p> <pre><code>mono = Monomial()\n</code></pre> <p>Create monomial with scalar \\(m\\) explicitly.</p> <pre><code>mono = Monomial('m')\n</code></pre> <p>Create monomial with scalar \\(w\\) and two deltas.</p> <pre><code>mono = Monomial('w', (0, 0), (1, 1))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>scalar</code> <code>str</code> <p>Monomial scalar.</p> <code>UNIT_MWP</code> <code>deltas</code> <code>Optional[Union[List[DELTA], DELTA]]</code> <p>A delta or a list of deltas.</p> <code>None</code> <code>*args</code> <code>Optional[DELTA]</code> <p>Arbitrary number of subsequent deltas.</p> <code>()</code>"},{"location":"monomial/#pymwp.monomial.Monomial.choice_scalar","title":"choice_scalar","text":"<pre><code>choice_scalar(*choices: int) -&gt; Optional[str]\n</code></pre> <p>Determine if given sequence of choices matches monomial.</p> <p>Parameters:</p> Name Type Description Default <code>choices</code> <code>int</code> <p>Tuple of choices.</p> <code>()</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Monomial's scalar if structure matches choices and None otherwise.</p>"},{"location":"monomial/#pymwp.monomial.Monomial.contains","title":"contains","text":"<pre><code>contains(m: Monomial) -&gt; bool\n</code></pre> <p>Check if all deltas of m are in deltas of self.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>Monomial</code> <p>A monomial to search for intersection.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>False if one delta of m not in self, True otherwise.</p>"},{"location":"monomial/#pymwp.monomial.Monomial.copy","title":"copy","text":"<pre><code>copy() -&gt; Monomial\n</code></pre> <p>Make a deep copy of a monomial.</p>"},{"location":"monomial/#pymwp.monomial.Monomial.inclusion","title":"inclusion","text":"<pre><code>inclusion(monomial: Monomial) -&gt; SetInclusion\n</code></pre> <p>Gives info about inclusion of self monomial with monomial.</p> <p>Parameters:</p> Name Type Description Default <code>monomial</code> <code>Monomial</code> <p>A monomial to see inclusion.</p> required <p>Returns:</p> Type Description <code>SetInclusion</code> <p>CONTAINS if self contains monomial, INCLUDED if self is included in monomial, and EMPTY none of them.</p>"},{"location":"monomial/#pymwp.monomial.Monomial.insert_delta","title":"insert_delta  <code>staticmethod</code>","text":"<pre><code>insert_delta(sorted_deltas: List[DELTA], delta: DELTA) -&gt; List[DELTA]\n</code></pre> <p>Takes as input a sorted list of deltas and a delta.</p> <p>Check if two deltas have the same index:</p> <p>If they do, and if they:</p> <ul> <li>disagree on the value expected, returns <code>[]</code> (empty list)</li> <li>agree on the value expected, returns the original deltas</li> </ul> <p>If they don't:</p> <ul> <li>add the new delta in the deltas \"at the right position\".</li> </ul> <p>Parameters:</p> Name Type Description Default <code>sorted_deltas</code> <code>List[DELTA]</code> <p>List of deltas where to perform insert.</p> required <code>delta</code> <code>DELTA</code> <p>The delta value to be inserted.</p> required <p>Returns:</p> Type Description <code>List[DELTA]</code> <p>updated list of deltas.</p>"},{"location":"monomial/#pymwp.monomial.Monomial.insert_deltas","title":"insert_deltas  <code>staticmethod</code>","text":"<pre><code>insert_deltas(monomial: Monomial, deltas: List[DELTA]) -&gt; None\n</code></pre> <p>Insert new deltas into monomial list of deltas.</p> <p>Parameters:</p> Name Type Description Default <code>monomial</code> <code>Monomial</code> <p>The monomial into whose list of deltas values will be inserted.</p> required <code>deltas</code> <code>List[DELTA]</code> <p>List of deltas to insert into monomial.</p> required"},{"location":"monomial/#pymwp.monomial.Monomial.prod","title":"prod","text":"<pre><code>prod(monomial: Monomial) -&gt; Monomial\n</code></pre> <p>Prod combines two monomials where one is this monomial (self) and the second is an argument.</p> <p>The attributes of the resulting monomial are determined as follows:</p> <ul> <li>output scalar is a product of the input scalars</li> <li>two lists of deltas are merged according to rules of insert_delta</li> </ul> <p>Parameters:</p> Name Type Description Default <code>monomial</code> <code>Monomial</code> <p>The second monomial.</p> required <p>Returns:</p> Type Description <code>Monomial</code> <p>A new Monomial that is a product of two monomials.</p>"},{"location":"monomial/#pymwp.monomial.Monomial.show","title":"show","text":"<pre><code>show() -&gt; None\n</code></pre> <p>Display scalar and the list of deltas.</p>"},{"location":"monomial/#pymwp.monomial.Monomial.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Get dictionary representation of a monomial.</p>"},{"location":"parser/","title":"parser.py","text":"<pre><code>from pymwp import Parser\n</code></pre> <p>Parser implementation is not a native part of pymwp.  Parsing is implemented with pycparser. The <code>Parser</code> module is simply a convenient wrapper.  Enhancements and issues with C-file parsing are out of scope of pymwp.</p>"},{"location":"parser/#pymwp.parser.ParserInterface","title":"ParserInterface","text":"<p>               Bases: <code>Nodes</code></p> <p>Interface for C code parser.</p>"},{"location":"parser/#pymwp.parser.ParserInterface.LoopT","title":"LoopT  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>LoopT: Type\n</code></pre> <p>Loop type.</p>"},{"location":"parser/#pymwp.parser.ParserInterface.Node","title":"Node  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>Node: Type\n</code></pre> <p>Base type for all AST nodes.</p>"},{"location":"parser/#pymwp.parser.ParserInterface.is_func","title":"is_func  <code>abstractmethod</code>","text":"<pre><code>is_func(node: Any) -&gt; bool\n</code></pre> <p>True if node is a function implementation.</p>"},{"location":"parser/#pymwp.parser.ParserInterface.is_loop","title":"is_loop  <code>abstractmethod</code>","text":"<pre><code>is_loop(node: Any) -&gt; bool\n</code></pre> <p>True is node is a loop statement.</p>"},{"location":"parser/#pymwp.parser.ParserInterface.parse","title":"parse  <code>abstractmethod</code> <code>staticmethod</code>","text":"<pre><code>parse(full_file_name: str, **kwargs) -&gt; dict\n</code></pre> <p>Extract text from the currently loaded file.</p>"},{"location":"parser/#pymwp.parser.ParserInterface.to_c","title":"to_c  <code>abstractmethod</code>","text":"<pre><code>to_c(node: Any) -&gt; str\n</code></pre> <p>Translate node back to C code.</p>"},{"location":"parser/#pymwp.parser.PyCParser","title":"PyCParser","text":"<p>               Bases: <code>ParserInterface</code></p> <p>Implementation of the parser interface using pycparser.</p>"},{"location":"parser/#pymwp.parser.PyCParser.LoopT","title":"LoopT  <code>property</code>","text":"<pre><code>LoopT: Type\n</code></pre> <p>Loop type.</p>"},{"location":"parser/#pymwp.parser.PyCParser.Node","title":"Node  <code>property</code>","text":"<pre><code>Node: Type\n</code></pre> <p>Base type for all AST nodes.</p>"},{"location":"parser/#pymwp.parser.PyCParser.add_attr_x","title":"add_attr_x  <code>staticmethod</code>","text":"<pre><code>add_attr_x(text: str) -&gt; str\n</code></pre> <p>Conditionally add <code>#define __attribute__(x)</code> to C file for pycparser.</p> <p>See: https://github.com/eliben/pycparser/wiki/FAQ#what-do-i-do -about-__attribute__/</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>C program file content as a string</p> required <p>Returns:</p> Type Description <code>str</code> <p>contents of C file, with <code>#define __attribute__(x)</code> included.</p>"},{"location":"parser/#pymwp.parser.PyCParser.is_func","title":"is_func","text":"<pre><code>is_func(node: Node) -&gt; bool\n</code></pre> <p>True if node is a (non-empty) function implementation.</p>"},{"location":"parser/#pymwp.parser.PyCParser.is_loop","title":"is_loop","text":"<pre><code>is_loop(node: Node) -&gt; bool\n</code></pre> <p>True is node is a loop statement.</p>"},{"location":"parser/#pymwp.parser.PyCParser.is_loop_nonempty","title":"is_loop_nonempty","text":"<pre><code>is_loop_nonempty(node: Node) -&gt; bool\n</code></pre> <p>True is node is a loop statement with non-empty body.</p>"},{"location":"parser/#pymwp.parser.PyCParser.to_c","title":"to_c","text":"<pre><code>to_c(node: Any, compact: bool = False) -&gt; str\n</code></pre> <p>Translate node back to C code.</p>"},{"location":"polynomial/","title":"polynomial.py","text":"<pre><code>from pymwp import Polynomial\n</code></pre>"},{"location":"polynomial/#pymwp.polynomial.Polynomial","title":"Polynomial","text":"<pre><code>Polynomial(*monomials: Optional[Union[str, Monomial, Tuple[str, DELTAS]]])\n</code></pre> <p>A polynomial is an ordered list of ordered Monomials.</p> <p>For polynomials, I introduce a total order on the monomials. This eases the computation of the sum: if we want to add a monomial to an ordered list of monomials, we compare the monomial to each of the elements of the list until we find either an element which is equal (and then we sum the scalars) or an element which is larger (and then we insert the new monomial there).</p> <p>Polynomials use the following ordering: \\(\\delta(i,j)\\) is smaller than \\(\\delta(m,n)\\) iff either \\(j&lt;n\\) or \\((j==n)\\) and \\((i&lt;m)\\).</p> <p>This is extended to products (which we consider ordered!) by letting \\(\\prod_k\\delta(i_k,j_k) &lt; \\prod_l\\delta(m_l,n_l)\\) iff \\(\\delta(i_1,j_1) &lt; \\delta(m_1,n_1)\\).</p> <p>Attributes:</p> Name Type Description <code>list</code> <code>List[Monomial]</code> <p>List of monomials.</p> <p>Create a polynomial.</p> Example <p>Create polynomial with 0-monomial:</p> <pre><code>zero = Polynomial()\n</code></pre> <p>Create polynomial with one monomial with specific scalar:</p> <pre><code>poly = Polynomial('w')               # shorthand\npoly = Polynomial(Monomial('w'))     # longer, equivalent\n</code></pre> <p>Create polynomial with two monomials and lists of deltas:</p> <pre><code>poly = Polynomial(('m', (0, 1)), ('w', (0, 0), (1, 1)))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>monomials</code> <code>Optional[Union[str, Monomial, Tuple[str, DELTAS]]]</code> <p>arbitrary monomials.</p> <code>()</code>"},{"location":"polynomial/#pymwp.polynomial.Polynomial.some_infty","title":"some_infty  <code>property</code>","text":"<pre><code>some_infty: bool\n</code></pre> <p>True if some monomial yields an infinity choice.</p>"},{"location":"polynomial/#pymwp.polynomial.Polynomial.add","title":"add","text":"<pre><code>add(polynomial: Polynomial) -&gt; Polynomial\n</code></pre> <p>Add two polynomials.</p> <ul> <li>If both lists are empty the result is empty.</li> <li>If one list is empty, the result will be the other list of polynomials.</li> </ul> <p>Otherwise, the operation will zip the two lists together and return a new polynomial of sorted monomials.</p> <p>Parameters:</p> Name Type Description Default <code>polynomial</code> <code>Polynomial</code> <p>Polynomial to add to self.</p> required <p>Returns:</p> Type Description <code>Polynomial</code> <p>New, sorted polynomial that is a sum of the two input polynomials.</p>"},{"location":"polynomial/#pymwp.polynomial.Polynomial.choice_scalar","title":"choice_scalar","text":"<pre><code>choice_scalar(*choices: int, least_scalar: str = None) -&gt; Optional[str]\n</code></pre> <p>For given sequence of choices, determine corresponding scalar.</p> <p>Parameters:</p> Name Type Description Default <code>choices</code> <code>int</code> <p>tuple of choices.</p> <code>()</code> <code>least_scalar</code> <code>str</code> <p>typically zero, but can be m on the diagonal.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Scalar value matching choices or None.</p>"},{"location":"polynomial/#pymwp.polynomial.Polynomial.compare","title":"compare  <code>staticmethod</code>","text":"<pre><code>compare(delta_list1: list, delta_list2: list) -&gt; Comparison\n</code></pre> <p>Compare 2 lists of deltas.</p> <p>We compare the initial segment up to the size of the shortest one. If the initial segments match, then the result is determined based on length. Three outputs are possible:</p> <ul> <li><code>SMALLER</code> if the first list is smaller than the second</li> <li><code>EQUAL</code> if both lists are equal in contents and length</li> <li><code>LARGER</code> if the first list is larger than the second</li> </ul> <p>The return value represents the relation of first list to the second one. <code>Smaller</code> means either</p> <ul> <li>delta values of first list are smaller -or-</li> <li>deltas are equal but first list is shorter.</li> </ul> <p>Larger is the opposite case.</p> <p>Parameters:</p> Name Type Description Default <code>delta_list1</code> <code>list</code> <p>first monomial list to compare.</p> required <code>delta_list2</code> <code>list</code> <p>second monomial list to compare.</p> required <p>Returns:</p> Type Description <code>Comparison</code> <p>Result of comparison.</p>"},{"location":"polynomial/#pymwp.polynomial.Polynomial.copy","title":"copy","text":"<pre><code>copy() -&gt; Polynomial\n</code></pre> <p>Make a deep copy of polynomial.</p>"},{"location":"polynomial/#pymwp.polynomial.Polynomial.equal","title":"equal","text":"<pre><code>equal(polynomial: Polynomial) -&gt; bool\n</code></pre> <p>Determine if two polynomials are equal.</p> <p>This method will compare current polynomial (self) to another polynomial provided as argument. Result of true means both polynomials have an equal number of monomials, and element-wise each monomial has the same list of deltas. Otherwise, the result is false.</p> <p>This method is alias of <code>==</code> operator.</p> <p>Parameters:</p> Name Type Description Default <code>polynomial</code> <code>Polynomial</code> <p>polynomial to compare.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if polynomials are equal and false otherwise.</p>"},{"location":"polynomial/#pymwp.polynomial.Polynomial.eval","title":"eval","text":"<pre><code>eval(*scalars: str) -&gt; List[DELTAS]\n</code></pre> <p>List of monomial deltas with scalar in *scalars. Scalars always includes \\(\\infty\\), but can include other flows.</p>"},{"location":"polynomial/#pymwp.polynomial.Polynomial.from_scalars","title":"from_scalars  <code>staticmethod</code>","text":"<pre><code>from_scalars(index: int, *scalars: str) -&gt; Polynomial\n</code></pre> <p>Build a polynomial of multiple monomials with deltas.</p> Example <p>For arguments <code>index=5</code> and <code>scalars= m, w, p</code>, the method returns a Polynomial equal to:</p> <pre><code>m1 = Monomial('m', (0, 5))\nm2 = Monomial('w', (1, 5))\nm3 = Monomial('p', (2, 5))\n\nPolynomial(m1, m2, m3)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Delta index.</p> required <code>scalars</code> <code>str</code> <p>Scalar values.</p> <code>()</code> <p>Returns:</p> Type Description <code>Polynomial</code> <p>Generated polynomial.</p>"},{"location":"polynomial/#pymwp.polynomial.Polynomial.inclusion","title":"inclusion  <code>staticmethod</code>","text":"<pre><code>inclusion(list_monom: list, mono: Monomial, i: int = 0) -&gt; Tuple[bool, int]\n</code></pre> <p>Filter list_monom regarding mono inclusion and return info.</p> <p>Remove all monomials of list_monom that are included in mono.</p> <p>Return CONTAINS if one of monomials of list_monom contains mono (regarding Monomial.inclusion def).</p> <p>Parameters:</p> Name Type Description Default <code>list_monom</code> <code>list</code> <p>A list of monomials.</p> required <code>mono</code> <code>Monomial</code> <p>A monomial we want to add.</p> required <code>i</code> <code>int</code> <p>The position index where to add mono.</p> <code>0</code> <p>Returns:</p> Type Description <code>Tuple[bool, int]</code> <p>False if mono already in list_monom and shifted index where to insert mono, return True if mono not in list_monom.</p>"},{"location":"polynomial/#pymwp.polynomial.Polynomial.remove_zeros","title":"remove_zeros","text":"<pre><code>remove_zeros() -&gt; Polynomial\n</code></pre> <p>Removes all encountered 0s from a polynomial.</p> <p>Before returning, if the list is empty, the result produces a     0-monomial.</p> <p>Returns:</p> Type Description <code>Polynomial</code> <p>polynomial with list of monomials for which zeros are</p> <code>Polynomial</code> <p>removed, unless 0 is the only monomial.</p>"},{"location":"polynomial/#pymwp.polynomial.Polynomial.show","title":"show","text":"<pre><code>show() -&gt; None\n</code></pre> <p>Display polynomial.</p>"},{"location":"polynomial/#pymwp.polynomial.Polynomial.sort_monomials","title":"sort_monomials  <code>staticmethod</code>","text":"<pre><code>sort_monomials(monomials: list) -&gt; list\n</code></pre> <p>Given a list of monomials this method will return them in order.</p> <p>The sort is performed by first dividing the list of monomials into halves recursively until each half contains at most one monomial. Then the sort will begin to combine (or zip) the halves into a sorted list.</p> <p>The sort performs comparison of deltas, and orders the monomials based on the delta values. If two monomials have the same deltas, we compute new scalar value, and if it is not 0, we keep the result monomial. Note that if we get 2 monomials with same deltas, and only at most 1 is kept, with possibly updated scalar. This means sort can return a result that is shorter than the input argument.</p> <p>The original list argument is not mutated by this sort operation, i.e. this is not sort in place.</p> <p>Parameters:</p> Name Type Description Default <code>monomials</code> <code>list</code> <p>list of monomials to sort.</p> required <p>Returns:</p> Type Description <code>list</code> <p>list of sorted monomials.</p>"},{"location":"polynomial/#pymwp.polynomial.Polynomial.times","title":"times","text":"<pre><code>times(polynomial: Polynomial) -&gt; Polynomial\n</code></pre> <p>Multiply two polynomials.</p> <p>Here we assume at least self is a sorted polynomial, and the result of this operation will be sorted.</p> <p>This operation works as follows:</p> <ol> <li> <p>We compute a table of all the separated products     \\(P.m_1,...,P.m_n\\). Each of the elements is itself     a sorted list of monomials: \\(P.m_j=m^j_1,...,m^j_k\\)</p> </li> <li> <p>We then sort the list of the first (smallest) elements     of each list. I.e. we sort the list \\(m^1_1,m^2_1,...,m^n_1\\)     and produce the list corresponding list of indexes of     length n, I.e. a permutation over \\({0,...,n}\\).</p> </li> <li> <p>Once all this preparatory operations are done, the main part    of the algorithm goes as follows:</p> </li> <li> <p>We consider the first element \u2014 say j \u2014 of the list of indexes    and append to the result the first element of the corresponding    list \\(P.m_j\\) of monomials.</p> </li> <li> <p>We remove both the first element of the list of index and    the first element of \\(P.m_j\\).</p> </li> <li> <p>If \\(P.m_j\\) is not empty, we insert j in the list of index    at the right position: for this we compare the (new) first    element of \\(P.m_j\\) to  \\(m^{i_2}_1\\) (as we removed the    first element, \\(i_2\\) is now the head of the list of indexes),    then \\(m^{i_3}_1\\), until we reach the index h such that    \\(m^{i_h}_1\\) is larger than \\(m^{j}_1\\).</p> </li> <li> <p>We start back at point 4. Unless only one element is left    in the list of indexes. In this case, we simply append the    tail of the corresponding list to the result.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>polynomial</code> <code>Polynomial</code> <p>polynomial to multiply with self.</p> required <p>Returns:</p> Type Description <code>Polynomial</code> <p>A new polynomial that is the sorted product of the two input polynomials.</p>"},{"location":"publications/","title":"Publications","text":""},{"location":"publications/#preferred-citation-format","title":"Preferred Citation Format","text":"<p>To reference pymwp, use: </p> <pre><code>@inproceedings{aubert2023,\n    title        = {pymwp: A Static Analyzer Determining Polynomial Growth Bounds},\n    author       = {Aubert, Cl{\\'e}ment and Rubiano, Thomas and Rusch, Neea and Seiller, Thomas},\n    year         = 2023,\n    booktitle    = {Automated Technology for Verification and Analysis},\n    publisher    = {Springer Nature Switzerland},\n    address      = {Cham},\n    pages        = {263--275},\n    doi          = {10.1007/978-3-031-45332-8_14},\n    isbn         = {978-3-031-45332-8},\n    editor       = {Andr{\\'e}, {\\'E}tienne and Sun, Jun}\n}\n</code></pre> <p>The article is available without paywall here.</p>"},{"location":"publications/#published-works","title":"Published Works","text":"<p>Mentions of pymwp in scientific literature.</p> <ul> <li> <p>Seiller, Thomas. \"Mathematical informatics.\" HDR, Universit\u00e9 Sorbonne Paris Nord, 2024. https://theses.hal.science/tel-04616661/</p> </li> <li> <p>Aubert, Cl\u00e9ment, Thomas Rubiano, Neea Rusch, and Thomas Seiller. \u201cPymwp: A Static Analyzer Determining Polynomial Growth Bounds.\u201d Automated Technology for Verification and Analysis, 2023, 263\u201375. https://doi.org/10.1007/978-3-031-45332-8_14.</p> </li> <li> <p>Rusch, Neea. \u201cFormally Verified Resource Bounds through Implicit Computational Complexity.\u201d Companion Proceedings of the 2022 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity, 2022, 17\u201320. https://doi.org/10.1145/3563768.3565545.</p> </li> <li> <p>Aubert, Cl\u00e9ment, Thomas Rubiano, Neea Rusch, and Thomas Seiller. \u201cMWP-analysis improvement and implementation: realizing implicit computational complexity.\u201c 7th International Conference on Formal Structures for Computation and Deduction (FSCD 2022). Leibniz International Proceedings in Informatics, vol. 228, pp. 26:1\u201326:23. Schloss Dagstuhl-Leibniz-Zentrum f\u00fcr Informatik (2022). https://doi.org/10.4230/LIPIcs.FSCD.2022.26.</p> </li> </ul>"},{"location":"relation/","title":"relation.py","text":"<pre><code>from pymwp import Relation\n</code></pre>"},{"location":"relation/#pymwp.relation.Relation","title":"Relation","text":"<pre><code>Relation(\n    variables: Optional[List[str]] = None, matrix: Optional[MATRIX] = None\n)\n</code></pre> <p>A relation is made of a list of variables and a 2D-matrix:</p> <ul> <li>Variables of a relation represent the variables of the input   program under analysis, for example: \\(X_0, X_1, X_2\\).</li> <li>Matrix holds Polynomials and represents the current state of   the analysis.</li> </ul> <p>Attributes:</p> Name Type Description <code>variables</code> <code>List[str]</code> <p>List of variables.</p> <code>matrix</code> <code>MATRIX</code> <p>Matrix.</p> <p>To construct a relation, provide a list of variables and an initial matrix.</p> <p>If matrix is not provided, the relation matrix will be initialized to zero matrix of size matching the number of variables.</p> Example <p>Create a new relation from a list of variables:</p> <pre><code>r = Relation(['X0', 'X1', 'X2'])\n</code></pre> <p>Creates relation with 0-matrix with and specified variables:</p> <pre><code>X0  |  0  0  0\nX1  |  0  0  0\nX2  |  0  0  0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>Optional[List[str]]</code> <p>Program variables.</p> <code>None</code> <code>matrix</code> <code>Optional[MATRIX]</code> <p>Relation matrix.</p> <code>None</code>"},{"location":"relation/#pymwp.relation.Relation.apply_choice","title":"apply_choice","text":"<pre><code>apply_choice(*choices: int) -&gt; SimpleRelation\n</code></pre> <p>Get the matrix corresponding to provided sequence of choices.</p> <p>Parameters:</p> Name Type Description Default <code>choices</code> <code>int</code> <p>Tuple of choices.</p> <code>()</code> <p>Returns:</p> Type Description <code>SimpleRelation</code> <p>New relation with simple-values matrix of scalars.</p>"},{"location":"relation/#pymwp.relation.Relation.composition","title":"composition","text":"<pre><code>composition(other: Relation) -&gt; Relation\n</code></pre> <p>Composition of current and another relation.</p> <p>Calling this method is equivalent to syntax <code>relation * relation</code>.</p> <p>Composition will:</p> <ol> <li>combine the variables of two relations, and</li> <li>produce a single matrix that is the product of matrices of     the two input relations.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Relation</code> <p>Relation to compose with current</p> required <p>Returns:</p> Type Description <code>Relation</code> <p>a new relation that is a product of inputs.</p>"},{"location":"relation/#pymwp.relation.Relation.equal","title":"equal","text":"<pre><code>equal(other: Relation) -&gt; bool\n</code></pre> <p>Determine if two relations are equal.</p> <p>For two relations to be equal they must have:</p> <ol> <li>the same variables (independent of order), and</li> <li>matrix polynomials must be equal element-wise.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Relation</code> <p>relation to compare</p> required <p>Returns:</p> Type Description <code>bool</code> <p>true when two relations are equal</p> <code>bool</code> <p>and false otherwise.</p>"},{"location":"relation/#pymwp.relation.Relation.eval","title":"eval","text":"<pre><code>eval(choices: List[int], index: int, *scalars: str) -&gt; Choices\n</code></pre> <p>Evaluate program matrix for possible derivation choices.</p> <p>Parameters:</p> Name Type Description Default <code>choices</code> <code>List[int]</code> <p>List of choices at each index, <code>[0,1,2]</code>.</p> required <code>index</code> <code>int</code> <p>Accumulated program counter.</p> required <code>scalars</code> <code>str</code> <p>Exclude specified scalars.</p> <code>()</code> <p>Returns:</p> Type Description <code>Choices</code> <p>A choice object for the evaluated matrix.</p>"},{"location":"relation/#pymwp.relation.Relation.fixpoint","title":"fixpoint","text":"<pre><code>fixpoint() -&gt; Relation\n</code></pre> <p>Compute sum of compositions until no changes occur.</p> <p>Returns:</p> Type Description <code>Relation</code> <p>resulting relation.</p>"},{"location":"relation/#pymwp.relation.Relation.homogenisation","title":"homogenisation  <code>staticmethod</code>","text":"<pre><code>homogenisation(r1: Relation, r2: Relation) -&gt; Tuple[Relation, Relation]\n</code></pre> <p>Performs homogenisation on two relations.</p> <p>After this operation both relations will have same variables and their matrices of the same size.</p> <p>This operation will internally resize matrices as needed.</p> <p>Parameters:</p> Name Type Description Default <code>r1</code> <code>Relation</code> <p>First relation to homogenise.</p> required <code>r2</code> <code>Relation</code> <p>Second relation to homogenise.</p> required <p>Returns:</p> Type Description <code>Tuple[Relation, Relation]</code> <p>Homogenised versions of the 2 inputs relations.</p>"},{"location":"relation/#pymwp.relation.Relation.identity","title":"identity  <code>staticmethod</code>","text":"<pre><code>identity(variables: List) -&gt; Relation\n</code></pre> <p>Create an identity relation.</p> <p>This method allows creating a relation whose matrix is an identity matrix.</p> <p>This is an alternative way to construct a relation.</p> Example <p>Create a new identity relation from a list of variables:</p> <pre><code>r = Relation.identity(['X0', 'X1', 'X2', 'X3'])\n</code></pre> <p>Creates relation with identity matrix with and variables:</p> <pre><code>X0  |  m  0  0  0\nX1  |  0  m  0  0\nX2  |  0  0  m  0\nX3  |  0  0  0  m\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>List</code> <p>A list of variables.</p> required <p>Returns:</p> Type Description <code>Relation</code> <p>Generated relation of given variables and an identity matrix.</p>"},{"location":"relation/#pymwp.relation.Relation.infty_pairs","title":"infty_pairs","text":"<pre><code>infty_pairs(only_incl: List[str] = None) -&gt; str\n</code></pre> <p>List of potential infinity dependencies.</p>"},{"location":"relation/#pymwp.relation.Relation.infty_vars","title":"infty_vars","text":"<pre><code>infty_vars(only_incl: List[str] = None) -&gt; Dict[str, List[str]]\n</code></pre> <p>Identify all variable pairs that for some choices, can raise infinity result.</p> <p>Returns:</p> Type Description <code>Dict[str, List[str]]</code> <p>Dictionary of potentially infinite dependencies, where the key is source variable and value is list of targets. All entries are non-empty.</p>"},{"location":"relation/#pymwp.relation.Relation.loop_correction","title":"loop_correction","text":"<pre><code>loop_correction(x_var: str, dg: DeltaGraph) -&gt; None\n</code></pre> <p>Loop correction to replace invalid scalars by \\(\\infty\\).</p> <p>Following computation of a loop fixpoint, this method checks the resulting matrix by rule L: scalars &gt;\\(m\\) at the diagonal become \\(\\infty\\). If exists M\\(_ij\\) = p then row X, col j =&gt; p.</p> <p>Related discussion issue #5.</p> <p>Parameters:</p> Name Type Description Default <code>x_var</code> <code>str</code> <p>Loop control variable.</p> required <code>dg</code> <code>DeltaGraph</code> <p>DeltaGraph instance.</p> required"},{"location":"relation/#pymwp.relation.Relation.relation_str","title":"relation_str  <code>staticmethod</code>","text":"<pre><code>relation_str(variables: List[str], matrix: MATRIX)\n</code></pre> <p>Formatted string of variables and matrix.</p>"},{"location":"relation/#pymwp.relation.Relation.replace_column","title":"replace_column","text":"<pre><code>replace_column(vector: List, variable: str) -&gt; Relation\n</code></pre> <p>Replace identity matrix column by a vector.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>List</code> <p>vector by which a matrix column will be replaced.</p> required <code>variable</code> <code>str</code> <p>program variable, column replacement will occur at the index of this variable.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if variable is not found in this relation.</p> <p>Returns:</p> Type Description <code>Relation</code> <p>new relation after applying the column replacement.</p>"},{"location":"relation/#pymwp.relation.Relation.show","title":"show","text":"<pre><code>show()\n</code></pre> <p>Display relation.</p>"},{"location":"relation/#pymwp.relation.Relation.sum","title":"sum","text":"<pre><code>sum(other: Relation) -&gt; Relation\n</code></pre> <p>Sum two relations.</p> <p>Calling this method is equivalent to syntax <code>relation + relation</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Relation</code> <p>Relation to sum with self.</p> required <p>Returns:</p> Type Description <code>Relation</code> <p>A new relation that is a sum of inputs.</p>"},{"location":"relation/#pymwp.relation.Relation.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Get dictionary representation of a relation.</p>"},{"location":"relation/#pymwp.relation.Relation.var_eval","title":"var_eval","text":"<pre><code>var_eval(\n    choices: List[int],\n    index: int,\n    variables: Union[str, List[str]] = None,\n    *scalars: str\n) -&gt; Union[Choices, Dict[str, Choices]]\n</code></pre> <p>Evaluate choices for each individual variable.</p> <p>This is same as <code>eval</code>, except it generates the choice-vectors column-wise.</p> <p>Parameters:</p> Name Type Description Default <code>choices</code> <code>List[int]</code> <p>List of choices at each index, <code>[0,1,2]</code></p> required <code>index</code> <code>int</code> <p>Accumulated program counter.</p> required <code>variables</code> <code>Union[str, List[str]]</code> <p>One or more variables to evaluate.</p> <code>None</code> <code>scalars</code> <code>str</code> <p>Exclude specified scalars.</p> <code>()</code> <p>Returns:</p> Type Description <code>Union[Choices, Dict[str, Choices]]</code> <p>A dictionary where the key is a variable name,</p> <code>Union[Choices, Dict[str, Choices]]</code> <p>and value is a choice object for the evaluated variable.</p>"},{"location":"relation/#pymwp.relation.Relation.while_correction","title":"while_correction","text":"<pre><code>while_correction(dg: DeltaGraph) -&gt; None\n</code></pre> <p>Replace invalid scalars in a matrix by \\(\\infty\\).</p> <p>Following the computation of fixpoint for a while loop node, this method checks the resulting matrix and replaces all invalid scalars with \\(\\infty\\) (W rule in MWP paper):</p> <ul> <li>scalar \\(p\\) anywhere in the matrix becomes \\(\\infty\\)</li> <li>scalar \\(w\\) at the diagonal becomes \\(\\infty\\)</li> </ul> Example <pre><code>   Before:                After:\n\n   | m  o  o  o  o |      | m  o  o  o  o |\n   | o  w  o  p  o |      | o  i  o  i  o |\n   | o  o  m  o  o |      | o  o  m  o  o |\n   | w  o  o  m  o |      | w  o  o  m  o |\n   | o  o  o  o  p |      | o  o  o  o  i |\n</code></pre> <p>Related discussion: issue #14.</p> <p>Parameters:</p> Name Type Description Default <code>dg</code> <code>DeltaGraph</code> <p>DeltaGraph instance.</p> required"},{"location":"relation/#pymwp.relation.SimpleRelation","title":"SimpleRelation","text":"<pre><code>SimpleRelation(\n    variables: Optional[List[str]] = None,\n    matrix: Optional[List[List[str]]] = None,\n)\n</code></pre> <p>               Bases: <code>Relation</code></p> <p>Specialized instance of relation, where matrix contains only    scalar values, no polynomials.</p> <p>A relation converts to a SimpleRelation by applying a derivation choice, see: <code>Relation.apply_choice</code>.</p>"},{"location":"relation_list/","title":"relation_list.py","text":"<pre><code>from pymwp import RelationList\n</code></pre>"},{"location":"relation_list/#pymwp.relation_list.RelationList","title":"RelationList","text":"<pre><code>RelationList(\n    variables: Optional[List[str]] = None,\n    relation_list: Optional[List[Relation]] = None,\n)\n</code></pre> <p>Relation list holds a list of <code>Relations</code>. It provides methods for performing operations collectively on all relations in the list.</p> <p>Attributes:</p> Name Type Description <code>relations</code> <code>List[Relation]</code> <p>List of relations.</p> <p>To create a relations list, specify either <code>variables</code> or <code>relation_list</code>.</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>Optional[List[str]]</code> <p>List of variables used to initialize a relation on relation list.</p> <code>None</code> <code>relation_list</code> <code>Optional[List[Relation]]</code> <p>List of relations for initializing relation list.</p> <code>None</code> <p>Specifying a <code>relation_list</code> argument of a list of <code>Relations</code>, initializes a <code>RelationList</code> containing the provided relations. If no <code>relation_list</code> argument is provided, the constructor will create a relation list with one relation, using the provided <code>variables</code> to initialize that relation.</p> Example <p>Create relation list using specific variables</p> <pre><code>rel_list = RelationList(['X0', 'X1', 'X2'])\n</code></pre> <p>Generates a list with 1 relation:</p> <pre><code>X0 |  +o  +o  +o\nX1 |  +o  +o  +o\nX2 |  +o  +o  +o\n</code></pre> <p>Create relation list by providing relations</p> <pre><code>relations = [Relation(['X0', 'X1']), Relation(['X0'])]\nrel_list = RelationList(relation_list=relations)\n</code></pre> <p>Generates a list with 2 relations:</p> <pre><code>1:      X0  |  +o  +o\n        X1  |  +o  +o\n\n2:      X0  |  +o\n</code></pre> <p>If no arguments are provided, the result is a relation list with an empty relation.</p> <pre><code>rel_list = RelationList()\n</code></pre> <p>Generates a list with 1 empty relation.</p>"},{"location":"relation_list/#pymwp.relation_list.RelationList.first","title":"first  <code>property</code>","text":"<pre><code>first: Relation\n</code></pre> <p>Gets the first relation in relation list.</p>"},{"location":"relation_list/#pymwp.relation_list.RelationList.composition","title":"composition","text":"<pre><code>composition(other: RelationList) -&gt; None\n</code></pre> <p>Apply composition to all relations in two relation lists.</p> <p>This method takes as argument <code>other</code> relation list, then composes the product of <code>self</code> and <code>other</code> by computing the product of each relation, for all combinations.</p> <p>Composition occurs in place. After composition <code>self</code> will contain all unique relations obtained during composition.</p> <p>To compose <code>RelationList</code> and a single <code>Relation</code>, see <code>one_composition()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>RelationList</code> <p>RelationList to compose with <code>self</code></p> required"},{"location":"relation_list/#pymwp.relation_list.RelationList.contains_matrix","title":"contains_matrix  <code>staticmethod</code>","text":"<pre><code>contains_matrix(search_in: List[Relation], matrix: List[List]) -&gt; bool\n</code></pre> <p>Check if a list of relations contains the provided matrix.</p> <p>Parameters:</p> Name Type Description Default <code>search_in</code> <code>List[Relation]</code> <p>list of relations to search</p> required <code>matrix</code> <code>List[List]</code> <p>search value to look for</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if matrix is found somewhere in the list of relations and <code>False</code> otherwise.</p>"},{"location":"relation_list/#pymwp.relation_list.RelationList.fixpoint","title":"fixpoint","text":"<pre><code>fixpoint() -&gt; None\n</code></pre> <p>Apply fixpoint to all relations in relation list.</p>"},{"location":"relation_list/#pymwp.relation_list.RelationList.identity","title":"identity  <code>staticmethod</code>","text":"<pre><code>identity(variables: List[str]) -&gt; RelationList\n</code></pre> <p>Create relation list that contains 1 identity relation.</p> <p>This is an alternative way to construct a relation list.</p> Example <p>Create relation list containing an identity relation</p> <pre><code>rel_list = RelationList.identity(['X0', 'X1', 'X2'])\n</code></pre> <p>Generates a list with 1 identity relation:</p> <pre><code>X0 |  +m  +o  +o\nX1 |  +o  +m  +o\nX2 |  +o  +o  +m\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>List[str]</code> <p>A list of variables.</p> required <p>Returns:</p> Type Description <code>RelationList</code> <p>RelationList that contains identity relation generated using the provided variables.</p>"},{"location":"relation_list/#pymwp.relation_list.RelationList.loop_correction","title":"loop_correction","text":"<pre><code>loop_correction(x_var: str, dg: DeltaGraph) -&gt; None\n</code></pre> <p>Apply loop correction.</p>"},{"location":"relation_list/#pymwp.relation_list.RelationList.one_composition","title":"one_composition","text":"<pre><code>one_composition(relation: Relation) -&gt; None\n</code></pre> <p>Compose each relation in a relation list \u00d7 relation.</p> <p>This method iterates current relation list and applies <code>composition()</code> to each of its relations, using argument <code>relation</code> as the other operand.</p> <p>Parameters:</p> Name Type Description Default <code>relation</code> <code>Relation</code> <p>relation to compose with relations in current list.</p> required"},{"location":"relation_list/#pymwp.relation_list.RelationList.replace_column","title":"replace_column","text":"<pre><code>replace_column(vector: list, variable: str) -&gt; None\n</code></pre> <p>For each relation in a relation list, replace column with a provided  vector, in place.</p> <p>This method takes as input a variable, then finds the index of that variable based on its name, then applies the column replacement at the discovered index.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>list</code> <p>vector that will replace a column</p> required <code>variable</code> <code>str</code> <p>variable value; replace will occur at the index of this variable.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if variable does not exists some relation belonging to this relation list.</p>"},{"location":"relation_list/#pymwp.relation_list.RelationList.show","title":"show","text":"<pre><code>show() -&gt; None\n</code></pre> <p>Display relation list.</p>"},{"location":"relation_list/#pymwp.relation_list.RelationList.while_correction","title":"while_correction","text":"<pre><code>while_correction(dg: DeltaGraph) -&gt; None\n</code></pre> <p>Apply <code>while_correction()</code> to all relations in a relation list.</p>"},{"location":"result/","title":"result.py","text":"<pre><code>from pymwp import Result\n</code></pre> <p>Result defines all information collected about an analyzed program. </p>"},{"location":"result/#pymwp.result.FuncLoops","title":"FuncLoops","text":"<pre><code>FuncLoops(name: str = None)\n</code></pre> <p>               Bases: <code>Timeable</code>, <code>Serializable</code></p> <p>Analysis result for a function with loops, when running loop analysis mode. <code>FuncLoops</code> captures the results for all loops inside their parent function.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Containing function name.</p> <code>loops</code> <code>Dict[str, LoopResult]</code> <p>Function loop analysis results.</p>"},{"location":"result/#pymwp.result.FuncLoops.n_loops","title":"n_loops  <code>property</code>","text":"<pre><code>n_loops: int\n</code></pre> <p>Number of analyzed loops</p>"},{"location":"result/#pymwp.result.FuncLoops.from_dict","title":"from_dict  <code>staticmethod</code>","text":"<pre><code>from_dict(**kwargs) -&gt; FuncLoops\n</code></pre> <p>Restore FuncLoops object.</p>"},{"location":"result/#pymwp.result.FuncResult","title":"FuncResult","text":"<pre><code>FuncResult(\n    name: str,\n    infinite: bool = False,\n    variables: Optional[List[str]] = None,\n    relation: Optional[Relation] = None,\n    choices: Optional[Choices] = None,\n    bound: Optional[Bound] = None,\n    inf_flows: Optional[str] = None,\n    index: int = -1,\n    func_code: str = None,\n)\n</code></pre> <p>               Bases: <code>Timeable</code>, <code>Serializable</code></p> <p>Analysis results for one function of the input program.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Function name.</p> <code>infinite</code> <code>bool</code> <p>True if no valid derivation exists.</p> <code>variables</code> <code>List[str]</code> <p>List of program variables.</p> <code>relation</code> <code>Relation</code> <p>Relation object; does not</p> <code>choices</code> <code>Choices</code> <p>A choice vector-object.</p> <code>bound</code> <code>Bound</code> <p>A bound of mwp-bounds.</p> <code>inf_flows</code> <code>str</code> <p>Description of problematic flows.</p> <code>index</code> <code>int</code> <p>Degree of derivation choice.</p> <code>func_code</code> <code>str</code> <p>Function source code.</p>"},{"location":"result/#pymwp.result.FuncResult.n_bounds","title":"n_bounds  <code>property</code>","text":"<pre><code>n_bounds: int\n</code></pre> <p>Number of bounds.</p>"},{"location":"result/#pymwp.result.FuncResult.n_vars","title":"n_vars  <code>property</code>","text":"<pre><code>n_vars: int\n</code></pre> <p>Number of variables.</p>"},{"location":"result/#pymwp.result.FuncResult.from_dict","title":"from_dict  <code>staticmethod</code>","text":"<pre><code>from_dict(name: str = None, **kwargs) -&gt; FuncResult\n</code></pre> <p>Deserialize a function result.</p>"},{"location":"result/#pymwp.result.FuncResult.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Serialize a function result.</p>"},{"location":"result/#pymwp.result.LoopResult","title":"LoopResult","text":"<pre><code>LoopResult(loop_code: str = None)\n</code></pre> <p>               Bases: <code>Timeable</code>, <code>Serializable</code></p> <p>Analysis result for one loop.</p> <p>Attributes:</p> Name Type Description <code>loop_code</code> <code>str</code> <p>The analyzed loop.</p> <code>variables</code> <code>Dict[str, VResult]</code> <p>Results by variable.</p>"},{"location":"result/#pymwp.result.LoopResult.as_bound","title":"as_bound  <code>property</code>","text":"<pre><code>as_bound: Bound\n</code></pre> <p>Combines variable results to a Bound-type.</p>"},{"location":"result/#pymwp.result.LoopResult.exp","title":"exp  <code>property</code>","text":"<pre><code>exp: List[str]\n</code></pre> <p>All variables with an unknown bound.</p>"},{"location":"result/#pymwp.result.LoopResult.linear","title":"linear  <code>property</code>","text":"<pre><code>linear: List[str]\n</code></pre> <p>All variables with a linear bound.</p>"},{"location":"result/#pymwp.result.LoopResult.loop_desc","title":"loop_desc  <code>property</code>","text":"<pre><code>loop_desc: str\n</code></pre> <p>Loop description =&gt; header block.</p>"},{"location":"result/#pymwp.result.LoopResult.n_bounded","title":"n_bounded  <code>property</code>","text":"<pre><code>n_bounded: int\n</code></pre> <p>Number of variables with a known bound.</p>"},{"location":"result/#pymwp.result.LoopResult.n_lines","title":"n_lines  <code>property</code>","text":"<pre><code>n_lines: int\n</code></pre> <p>Number of code lines in a loop.</p>"},{"location":"result/#pymwp.result.LoopResult.n_vars","title":"n_vars  <code>property</code>","text":"<pre><code>n_vars: int\n</code></pre> <p>Number of variables.</p>"},{"location":"result/#pymwp.result.LoopResult.poly","title":"poly  <code>property</code>","text":"<pre><code>poly: List[str]\n</code></pre> <p>All variables with a polynomial bound.</p>"},{"location":"result/#pymwp.result.LoopResult.weak","title":"weak  <code>property</code>","text":"<pre><code>weak: List[str]\n</code></pre> <p>All variables with a weak polynomial bound.</p>"},{"location":"result/#pymwp.result.LoopResult.from_dict","title":"from_dict  <code>staticmethod</code>","text":"<pre><code>from_dict(**kwargs) -&gt; LoopResult\n</code></pre> <p>Restore LoopResult object.</p>"},{"location":"result/#pymwp.result.LoopResult.var_sat","title":"var_sat","text":"<pre><code>var_sat(cond: Callable[[VResult], bool]) -&gt; List[str]\n</code></pre> <p>List of variables satisfying a condition.</p>"},{"location":"result/#pymwp.result.Program","title":"Program","text":"<pre><code>Program(\n    program_path: str = None,\n    n_lines: int = -1,\n    n_func: int = 0,\n    n_loops: int = 0,\n    n_loop_for: int = 0,\n    n_func_vars: int = 0,\n    n_loop_vars: int = 0,\n)\n</code></pre> <p>               Bases: <code>Serializable</code></p> <p>Details about analyzed C-language input file.</p> <p>Attributes:</p> Name Type Description <code>program_path</code> <code>str</code> <p>Path to program file.</p> <code>n_lines</code> <code>int</code> <p>Lines of code in input program.</p> <code>n_func</code> <code>int</code> <p>Total functions (incl. un-analyzed).</p> <code>n_loops</code> <code>int</code> <p>Total loops (incl. un-analyzed).</p> <code>n_loops_for</code> <code>int</code> <p>Total for loops (within n_loops).</p> <code>n_func_vars</code> <code>int</code> <p>Total function variables (incl. un-analyzed).</p> <code>n_loop_vars</code> <code>int</code> <p>Total loop variables (incl. un-analyzed).</p>"},{"location":"result/#pymwp.result.Program.name","title":"name  <code>property</code>","text":"<pre><code>name: Optional[str]\n</code></pre> <p>Get program name without path and extension.</p>"},{"location":"result/#pymwp.result.Program.from_dict","title":"from_dict  <code>staticmethod</code>","text":"<pre><code>from_dict(**kwargs) -&gt; Program\n</code></pre> <p>Restore Program object.</p>"},{"location":"result/#pymwp.result.Result","title":"Result","text":"<pre><code>Result()\n</code></pre> <p>               Bases: <code>Timeable</code>, <code>Serializable</code></p> <p>Captures analysis result and details about the analysis process.</p> <p>Attributes:</p> Name Type Description <code>program</code> <code>Program</code> <p>Information about analyzed C File.</p> <code>relations</code> <code>Dict[str, FuncResult]</code> <p>Dictionary of function results.</p> <code>loops</code> <code>Dict[str, FuncLoops]</code> <p>Dictionary of function loop results.</p>"},{"location":"result/#pymwp.result.Result.n_functions","title":"n_functions  <code>property</code>","text":"<pre><code>n_functions: int\n</code></pre> <p>Number of analyzed functions in program.</p>"},{"location":"result/#pymwp.result.Result.n_loops","title":"n_loops  <code>property</code>","text":"<pre><code>n_loops: int\n</code></pre> <p>Number of analyzed loops in program.</p>"},{"location":"result/#pymwp.result.Result.add_loop","title":"add_loop","text":"<pre><code>add_loop(result: FuncLoops) -&gt; None\n</code></pre> <p>Append loop analysis to result.</p>"},{"location":"result/#pymwp.result.Result.add_relation","title":"add_relation","text":"<pre><code>add_relation(result: FuncResult) -&gt; None\n</code></pre> <p>Appends function analysis to result.</p>"},{"location":"result/#pymwp.result.Result.from_dict","title":"from_dict  <code>staticmethod</code>","text":"<pre><code>from_dict(**kwargs) -&gt; Result\n</code></pre> <p>Restore Result object.</p>"},{"location":"result/#pymwp.result.Result.get_func","title":"get_func","text":"<pre><code>get_func(\n    name: Optional[str] = None,\n) -&gt; Union[FuncResult, FuncLoops, Dict[str, FuncResult], Dict[str, FuncLoops]]\n</code></pre> <p>Returns analysis result for function(s).</p> <p>Here \"analysis\" means either whole-function analysis, or loop analysis, based on executed analysis mode; they cannot co-exist in the same result.</p> <ul> <li>If <code>name</code> argument is provided and key exists, returns a result  for exact value match.</li> <li>If program contained exactly 1 function, returns result for that   function.</li> <li>Otherwise, returns a dictionary of results for each analyzed   function, as in: <code>&lt;function_name, analysis_result&gt;</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Name of function.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[FuncResult, FuncLoops, Dict[str, FuncResult], Dict[str, FuncLoops]]</code> <p>A function analysis result, or a dictionary of results.</p>"},{"location":"result/#pymwp.result.Result.log_result","title":"log_result","text":"<pre><code>log_result() -&gt; Result\n</code></pre> <p>Display here all interesting stats about analysis result.</p>"},{"location":"result/#pymwp.result.Result.pretty_print","title":"pretty_print  <code>staticmethod</code>","text":"<pre><code>pretty_print(\n    txt: str, line_w: int = 50, hb: str = \"\u2500\", color: bool = False\n) -&gt; str\n</code></pre> <p>Draws a colored box around text before display.</p> <p>Parameters:</p> Name Type Description Default <code>txt</code> <code>str</code> <p>Some text to display.</p> required <code>line_w</code> <code>int</code> <p>Formatted text line width.</p> <code>50</code> <code>hb</code> <code>str</code> <p>Horizontal bar box-drawing character</p> <code>'\u2500'</code> <code>color</code> <code>bool</code> <p>Apply color to output</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Formatted text.</p>"},{"location":"result/#pymwp.result.Serializable","title":"Serializable","text":"<p>               Bases: <code>ABC</code></p> <p>General utilities for converting results to JSON-writable objects and vice versa.</p>"},{"location":"result/#pymwp.result.Serializable.from_dict","title":"from_dict  <code>abstractmethod</code> <code>staticmethod</code>","text":"<pre><code>from_dict(**kwargs) -&gt; Serializable\n</code></pre> <p>Restore object from a dictionary; reverses <code>to_dict()</code>.</p>"},{"location":"result/#pymwp.result.Serializable.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert an object to a JSON-compatible dictionary.</p>"},{"location":"result/#pymwp.result.Timeable","title":"Timeable","text":"<pre><code>Timeable()\n</code></pre> <p>Represents an entity whose runtime can be measured.</p> <p>Attributes:</p> Name Type Description <code>start_time</code> <code>int</code> <p>recorded start time.</p> <code>end_time</code> <code>int</code> <p>recorded end time.</p>"},{"location":"result/#pymwp.result.Timeable.dur_ms","title":"dur_ms  <code>property</code>","text":"<pre><code>dur_ms: int\n</code></pre> <p>Duration in milliseconds.</p>"},{"location":"result/#pymwp.result.Timeable.dur_s","title":"dur_s  <code>property</code>","text":"<pre><code>dur_s: float\n</code></pre> <p>Duration in seconds.</p>"},{"location":"result/#pymwp.result.Timeable.time_diff","title":"time_diff  <code>property</code>","text":"<pre><code>time_diff: int\n</code></pre> <p>Time delta between analysis start and end time.</p>"},{"location":"result/#pymwp.result.Timeable.on_emit","title":"on_emit","text":"<pre><code>on_emit() -&gt; Timeable\n</code></pre> <p>Potentially called at intermediate steps.</p>"},{"location":"result/#pymwp.result.Timeable.on_end","title":"on_end","text":"<pre><code>on_end() -&gt; Timeable\n</code></pre> <p>Called at end of timeable entity.</p>"},{"location":"result/#pymwp.result.Timeable.on_start","title":"on_start","text":"<pre><code>on_start() -&gt; Timeable\n</code></pre> <p>Called at start of timeable entity.</p>"},{"location":"result/#pymwp.result.VResult","title":"VResult","text":"<pre><code>VResult(\n    name: str = None,\n    is_m: bool = False,\n    is_w: bool = False,\n    is_p: bool = False,\n    bound: MwpBound = None,\n    choices: Choices = None,\n)\n</code></pre> <p>               Bases: <code>Serializable</code></p> <p>Analysis result for a single variable.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Variable name.</p> <code>is_m</code> <code>bool</code> <p>Has maximal linear bound.</p> <code>is_w</code> <code>bool</code> <p>Has weak polynomial bound.</p> <code>is_p</code> <code>bool</code> <p>Has polynomial bound.</p> <code>bound</code> <code>Optional[MwpBound]</code> <p>A bound (if exists).</p> <code>choices</code> <code>Optional[Choice]</code> <p>Bound choices.</p>"},{"location":"result/#pymwp.result.VResult.exponential","title":"exponential  <code>property</code>","text":"<pre><code>exponential\n</code></pre> <p>Variable has no known bound (polynomial or less).</p>"},{"location":"result/#pymwp.result.VResult.is_m","title":"is_m  <code>property</code> <code>writable</code>","text":"<pre><code>is_m: bool\n</code></pre> <p>Variable has a max of linear bound.</p>"},{"location":"result/#pymwp.result.VResult.is_p","title":"is_p  <code>property</code> <code>writable</code>","text":"<pre><code>is_p: bool\n</code></pre> <p>Variable has a polynomial bound.</p>"},{"location":"result/#pymwp.result.VResult.is_w","title":"is_w  <code>property</code> <code>writable</code>","text":"<pre><code>is_w: bool\n</code></pre> <p>Variable has a weak polynomial bound.</p>"},{"location":"result/#pymwp.result.VResult.from_dict","title":"from_dict  <code>staticmethod</code>","text":"<pre><code>from_dict(**kwargs) -&gt; VResult\n</code></pre> <p>Restore VResult object.</p>"},{"location":"result/#pymwp.result.VResult.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Serialize a VResult object.</p>"},{"location":"semiring/","title":"semiring.py","text":"<pre><code>from pymwp.semiring import KEYS, ZERO_MWP, UNIT_MWP, prod_mwp, sum_mwp\n</code></pre>"},{"location":"semiring/#pymwp.semiring.INFTY_MWP","title":"INFTY_MWP  <code>module-attribute</code>","text":"<pre><code>INFTY_MWP: str = 'i'\n</code></pre> <p>Scalar that represents failure in the analysis (<code>'i'</code>), \\(\\infty\\).</p>"},{"location":"semiring/#pymwp.semiring.KEYS","title":"KEYS  <code>module-attribute</code>","text":"<pre><code>KEYS: List[str] = [ZERO_MWP, UNIT_MWP, WEAK_MWP, POLY_MWP, INFTY_MWP]\n</code></pre> <p>Different scalar values: <code>\"o\", \"m\", \"w\", \"p\", \"i\"</code></p>"},{"location":"semiring/#pymwp.semiring.POLY_MWP","title":"POLY_MWP  <code>module-attribute</code>","text":"<pre><code>POLY_MWP: str = 'p'\n</code></pre> <p>Scalar that represents a polynomial flow in the analysis (<code>'p'</code>).</p>"},{"location":"semiring/#pymwp.semiring.UNIT_MWP","title":"UNIT_MWP  <code>module-attribute</code>","text":"<pre><code>UNIT_MWP: str = 'm'\n</code></pre> <p>Scalar that represents maximally linear flow in the analysis (<code>'m'</code>).</p>"},{"location":"semiring/#pymwp.semiring.WEAK_MWP","title":"WEAK_MWP  <code>module-attribute</code>","text":"<pre><code>WEAK_MWP: str = 'w'\n</code></pre> <p>Scalar that represents weak polynomial flow in the analysis (<code>'w'</code>).</p>"},{"location":"semiring/#pymwp.semiring.ZERO_MWP","title":"ZERO_MWP  <code>module-attribute</code>","text":"<pre><code>ZERO_MWP: str = 'o'\n</code></pre> <p>Scalar that represents no dependency (0) in the analysis (<code>'o'</code>).</p>"},{"location":"semiring/#pymwp.semiring.mwp_sort","title":"mwp_sort","text":"<pre><code>mwp_sort(scalars: List[str])\n</code></pre> <p>Ascending sort of scalars (o &lt; m &lt; w &lt; p &lt; \\(\\infty\\)).</p>"},{"location":"semiring/#pymwp.semiring.prod_mwp","title":"prod_mwp","text":"<pre><code>prod_mwp(scalar1: str, scalar2: str) -&gt; str\n</code></pre> <p>Compute product of two scalars.</p> \\(\\times\\) \\(0\\) \\(m\\) \\(w\\) \\(p\\) \\(\\infty\\) \\(0\\) \\(0\\) \\(0\\) \\(0\\) \\(0\\) \\(\\infty\\) \\(m\\) \\(0\\) \\(m\\) \\(w\\) \\(p\\) \\(\\infty\\) \\(w\\) \\(0\\) \\(w\\) \\(w\\) \\(p\\) \\(\\infty\\) \\(p\\) \\(0\\) \\(p\\) \\(p\\) \\(p\\) \\(\\infty\\) \\(\\infty\\) \\(\\infty\\) \\(\\infty\\) \\(\\infty\\) \\(\\infty\\) \\(\\infty\\) <p>Parameters:</p> Name Type Description Default <code>scalar1</code> <code>str</code> <p>scalar value.</p> required <code>scalar2</code> <code>str</code> <p>scalar value.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>if <code>scalar1</code> or <code>scalar2</code> is not in KEYS.</p> <p>Returns:</p> Type Description <code>str</code> <p>Product of scalar1 * scalar2.</p>"},{"location":"semiring/#pymwp.semiring.sum_mwp","title":"sum_mwp","text":"<pre><code>sum_mwp(scalar1: str, scalar2: str) -&gt; str\n</code></pre> <p>Compute sum of two scalars.</p> \\(+\\) \\(0\\) \\(m\\) \\(w\\) \\(p\\) \\(\\infty\\) \\(0\\) \\(0\\) \\(m\\) \\(w\\) \\(p\\) \\(\\infty\\) \\(m\\) \\(m\\) \\(m\\) \\(w\\) \\(p\\) \\(\\infty\\) \\(w\\) \\(w\\) \\(w\\) \\(w\\) \\(p\\) \\(\\infty\\) \\(p\\) \\(p\\) \\(p\\) \\(p\\) \\(p\\) \\(\\infty\\) \\(\\infty\\) \\(\\infty\\) \\(\\infty\\) \\(\\infty\\) \\(\\infty\\) \\(\\infty\\) <p>Parameters:</p> Name Type Description Default <code>scalar1</code> <code>str</code> <p>scalar value.</p> required <code>scalar2</code> <code>str</code> <p>scalar value.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>if <code>scalar1</code> or <code>scalar2</code> is not in KEYS.</p> <p>Returns:</p> Type Description <code>str</code> <p>Sum of scalar1 + scalar2.</p>"},{"location":"syntax/","title":"syntax.py","text":"<pre><code>from pymwp import Coverage, Variables\n</code></pre> <p>Various light syntactic pre-analyses/pre-processors.</p> <ul> <li><code>Coverage</code> checks that input C file follows supported language features.<ul> <li>Running pymwp with <code>--strict</code> flag ensures only passing inputs are analyzed.</li> <li>Otherwise, unsupported commands are removed from AST before analysis.</li> </ul> </li> <li><code>FindLoops</code> recursively finds all loop-nodes in an AST.</li> <li><code>Variables</code> recursively finds variables in an AST.</li> </ul>"},{"location":"syntax/#pymwp.syntax.BaseAnalysis","title":"BaseAnalysis","text":"<p>               Bases: <code>NodeHandler</code></p> <p>Base implementation for AST analysis.</p>"},{"location":"syntax/#pymwp.syntax.BaseAnalysis.BIN_OPS","title":"BIN_OPS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BIN_OPS = {PLUS, MINUS, MULT}\n</code></pre> <p>Supported binary operators.</p>"},{"location":"syntax/#pymwp.syntax.BaseAnalysis.U_OPS","title":"U_OPS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>U_OPS = INC | DEC | {PLUS, MINUS, NEG, SIZEOF}\n</code></pre> <p>Supported unary operators.</p>"},{"location":"syntax/#pymwp.syntax.BaseAnalysis.handler","title":"handler  <code>abstractmethod</code>","text":"<pre><code>handler(node: Node, *args, **kwargs) -&gt; None\n</code></pre> <p>Handler for AST nodes that meet some abstract criteria.</p>"},{"location":"syntax/#pymwp.syntax.BaseAnalysis.recurse","title":"recurse","text":"<pre><code>recurse(node: Node, *args, **kwargs) -&gt; None\n</code></pre> <p>Traverse AST nodes.</p>"},{"location":"syntax/#pymwp.syntax.Coverage","title":"Coverage","text":"<pre><code>Coverage(node: Node)\n</code></pre> <p>               Bases: <code>BaseAnalysis</code></p> <p>Simple analysis of AST syntax to determine if AST contains only supported language features.</p> <p>Attributes:</p> Name Type Description <code>node(pr.Node)</code> <p>AST node.</p> <code>omit(List[str])</code> <p>List of unsupported commands.</p> <code>clear_list(List[Callable])</code> <p>Functions to clear unsupported syntax.</p>"},{"location":"syntax/#pymwp.syntax.Coverage.full","title":"full  <code>property</code>","text":"<pre><code>full: bool\n</code></pre> <p>True if entire syntax tree is fully covered by analysis.</p>"},{"location":"syntax/#pymwp.syntax.Coverage.ast_mod","title":"ast_mod","text":"<pre><code>ast_mod() -&gt; Coverage\n</code></pre> <p>Removes unsupported AST nodes in place.</p>"},{"location":"syntax/#pymwp.syntax.Coverage.handler","title":"handler","text":"<pre><code>handler(node: Node, *args, **kwargs)\n</code></pre> <p>Make a list of uncovered nodes.</p>"},{"location":"syntax/#pymwp.syntax.Coverage.loop_compat","title":"loop_compat  <code>staticmethod</code>","text":"<pre><code>loop_compat(node: For) -&gt; Tuple[bool, Optional[str]]\n</code></pre> <p>Check if C-language for loop is compatible with an \"mwp-loop\".</p> <p>The mwp-loop has form \\(\\text{loop} \\; \\texttt{X} \\; \\{ \\texttt{C} \\}\\). Try to identify if C-language <code>for</code> loop has a similar form, repeat X times command C. The variable X is not allowed to occur in the body C of the loop.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>For</code> <p>AST node to inspect.</p> required <p>Returns:</p> Type Description <code>Tuple[bool, Optional[str]]</code> <p>A tuple where the first item is a compatibility result: True if for loop is mwp-loop compatible, otherwise False. The second is the name of iteration guard variable X, possibly <code>None</code>.</p>"},{"location":"syntax/#pymwp.syntax.Coverage.report","title":"report","text":"<pre><code>report() -&gt; Coverage\n</code></pre> <p>Display syntax coverage for inspected AST node.</p>"},{"location":"syntax/#pymwp.syntax.FindLoops","title":"FindLoops","text":"<pre><code>FindLoops(node: Node)\n</code></pre> <p>               Bases: <code>BaseAnalysis</code></p> <p>Finds all loop nodes in an AST.</p> <p>Attributes:</p> Name Type Description <code>loops</code> <code>List[LoopT]</code> <p>Loop nodes.</p>"},{"location":"syntax/#pymwp.syntax.FindLoops.handler","title":"handler","text":"<pre><code>handler(node: LoopT, *args, **kwargs) -&gt; None\n</code></pre> <p>Make a (flat) list of the discovered loops.</p>"},{"location":"syntax/#pymwp.syntax.SyntaxUtils","title":"SyntaxUtils","text":"<p>Various helpful syntax-related utility methods.</p>"},{"location":"syntax/#pymwp.syntax.SyntaxUtils.array_name","title":"array_name  <code>staticmethod</code>","text":"<pre><code>array_name(node: ArrayRef) -&gt; str\n</code></pre> <p>Find array identifier.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>ArrayRef</code> <p>Array AST node.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Find array name from node.</p>"},{"location":"syntax/#pymwp.syntax.SyntaxUtils.init_vars","title":"init_vars  <code>staticmethod</code>","text":"<pre><code>init_vars(\n    node: Union[Assignment, DeclList, ExprList, None],\n) -&gt; tuple[list[Any], list[Any]]\n</code></pre> <p>Find and group variables in an init-block.</p> <p>Looks for declarations/iterators <code>int i=\u2026,\u2026</code> on left and \"source\" variables <code>\u2026=y</code> on right.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Union[Assignment, DeclList, ExprList, None]</code> <p>Node to inspect.</p> required <p>Returns:</p> Type Description <code>tuple[list[Any], list[Any]]</code> <p>Discovered variable lists of declarations and sources.</p>"},{"location":"syntax/#pymwp.syntax.SyntaxUtils.print_mod","title":"print_mod  <code>staticmethod</code>","text":"<pre><code>print_mod(node: Node) -&gt; Node\n</code></pre> <p>Prepare AST node for display as string.</p> <p>For example, for long blocks the body statement is removed. The original node is never modified; if some edit is applied, it is always applied to a copy of the AST node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>AST node.</p> required <p>Returns:</p> Type Description <code>Node</code> <p>AST node conditionally formatted for display.</p>"},{"location":"syntax/#pymwp.syntax.SyntaxUtils.rm_attr","title":"rm_attr  <code>staticmethod</code>","text":"<pre><code>rm_attr(node: Node, attr: str) -&gt; Callable\n</code></pre> <p>Construct a callable function to clear an attribute.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>AST node.</p> required <code>attr</code> <code>str</code> <p>Attribute to remove.</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>A callable function.</p>"},{"location":"syntax/#pymwp.syntax.SyntaxUtils.rm_child","title":"rm_child  <code>staticmethod</code>","text":"<pre><code>rm_child(node: Node, attr: str, child: Node) -&gt; Callable\n</code></pre> <p>Construct a callable function to remove a child node.</p> <p>Using a callable allows performing the actual removal later.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>Parent node.</p> required <code>attr</code> <code>str</code> <p>Parent's attribute that contains child, e.g., stmt.</p> required <code>child</code> <code>Node</code> <p>Child node.</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>A callable function.</p>"},{"location":"syntax/#pymwp.syntax.SyntaxUtils.unsupported","title":"unsupported  <code>staticmethod</code>","text":"<pre><code>unsupported(omits: List[str]) -&gt; None\n</code></pre> <p>Display unsupported nodes as an ordered list.</p> <p>Parameters:</p> Name Type Description Default <code>omits</code> <code>List[str]</code> <p>List of unsupported AST nodes.</p> required"},{"location":"syntax/#pymwp.syntax.Variables","title":"Variables","text":"<pre><code>Variables(*nodes: Node)\n</code></pre> <p>               Bases: <code>BaseAnalysis</code></p> <p>Find variables in an AST.</p> <p>Attributes:</p> Name Type Description <code>vars</code> <code>List[str]</code> <p>List of variables.</p>"},{"location":"syntax/#pymwp.syntax.Variables.RESERVED","title":"RESERVED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESERVED = ['true', 'false']\n</code></pre> <p>List of reserved names that are not variables; see issue #150.</p>"},{"location":"syntax/#pymwp.syntax.Variables.handler","title":"handler","text":"<pre><code>handler(node: Node, *args, **kwargs)\n</code></pre> <p>Record the name of a discovered variable.</p>"},{"location":"syntax/#pymwp.syntax.Variables.loop_guard","title":"loop_guard  <code>staticmethod</code>","text":"<pre><code>loop_guard(node: For) -&gt; Tuple[List[str], List[str]]\n</code></pre> <p>Find variables in a for loop.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>For</code> <p>A for-loop AST node.</p> required <p>Returns:</p> Type Description <code>Tuple[List[str], List[str]]</code> <p>Two lists of variables: <code>(loop_guard, body_variables)</code>.</p>"},{"location":"utilities/","title":"Evaluation Utilities","text":"<p>There are several make commands and utility scripts in the repository's <code>utilities</code> directory.  They help inspect, test, measure and report of performance of pymwp.  These tools are not shipped with the distributed version of pymwp, but are available from the source code repository.</p> <ul> <li> AST Generator Convert C files to ASTs using pycparser.</li> <li> Machine Details Captures host machine details at runtime.</li> <li> Plot Results Make table plots of pymwp results.</li> <li> Profiling Inspect functions runtime execution details.</li> </ul> <p>Required dependencies</p> <p>First install required dependencies for running utilities:</p> <pre><code>python -m pip install -r requirements-dev.txt\n</code></pre>"},{"location":"utilities/#ast-generator","title":"AST Generator","text":"<p>This is a utility script that reads and parses a C file, or a directory of C files, then generates an AST. It uses gcc and pycparser, then writes the AST to a file. This script is mainly useful for generating/updating test cases for unit testing, and for inspecting AST structure and nodes. The parser options are hard-coded, and assumes C files have no custom headers, and that gcc is an existing system C compiler.</p> Usage: <pre><code>python3 utilities/ast_util.py IN_PATH OUT_DIR\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>IN_PATH</code> <code>str</code> <p>A C file or path to a directory of C files.</p> required <code>OUT_DIR</code> <code>str</code> <p>Directory where to save AST.</p> required"},{"location":"utilities/#machine-details","title":"Machine Details","text":"<p>Capture details of the current machine and runtime.</p> Usage: <pre><code>python3 utilities/runtime.py OUTPUT_DIR\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>OUTPUT_DIR</code> <code>str</code> <p>Directory where to write the output.</p> required"},{"location":"utilities/#plot-results","title":"Plot Results","text":"<p>Makes a table plot of analysis results.</p> Usage: <pre><code>python3 utilities/plot.py  --in IN --out OUT --fmt FORMAT\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>--in</code> <code>str</code> <p>Directory of analysis results.</p> required <code>--out</code> <code>str</code> <p>Directory where to save generated plot.</p> required <code>--fmt</code> <code>str</code> <p>Plot format: <code>tex</code> or <code>plain</code>.</p> required"},{"location":"utilities/#profiling","title":"Profiling","text":"<p>Profiling reveals how many times different functions are called during analysis. Profiling is based on Python cProfile.</p> <p>See: https://docs.python.org/3/library/profile.html</p>"},{"location":"utilities/#utilities.profiler--single-file-profile","title":"Single file profile","text":"<p>Single-file profiling works on both pymwp installed from package registry or when running pymwp from source, because it requires only the standard Python module cProfile.</p> Usage: Release versionRunning from source <pre><code>python -m cProfile pymwp --silent -s ncalls INPUT_FILE\n</code></pre> <pre><code>python -m cProfile -m pymwp --silent -s ncalls INPUT_FILE\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>INPUT_FILE</code> <code>str</code> <p>Path to input C file.</p> required <code>--silent</code> <p>Mute pymwp analysis output.</p> required <code>-s</code> <code>str</code> <p>Specifies cProfile output sort order.</p> required <p>See: https://docs.python.org/3/library/profile.html#pstats.Stats.sort_stats</p> <p>Additional arguments of cProfile or pymwp can be added similarly.</p>"},{"location":"utilities/#utilities.profiler--multi-file-profile","title":"Multi-file profile","text":"<p>Profiler utility module is a wrapper for cProfile. It enables profiling directories of C files. The results of each execution are stored in corresponding output files.</p> One outputs is displayed for each profiled file: <p>done-ok profiling subprocess terminated without error, note: even if pymwp analysis ends with non-0 exit code, it falls into this category if it does not crash the subprocess.</p> <p>error profiling subprocess terminated in error.</p> <p>timeout profiling subprocess did not terminate within time limit and was forced to quit.</p> Usage: <p>Profile all repository examples:</p> <pre><code>make profile\n</code></pre> <p>Run with custom arguments:</p> <pre><code>python utilities/profiler.py --in IN --out OUT --sort SORT --timeout SEC\n       --lines LINES --skip SKIP --only ONLY --extern --callers --save --help\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>--in</code> <code>str</code> <p>Directory path to C-files [default: c_files].</p> required <code>--out</code> <code>str</code> <p>Directory path for storing results [default: <code>output/profile</code>].</p> required <code>--sort</code> <code>str</code> <p>Property to sort by [default: <code>calls</code>].</p> required <code>--timeout</code> <code>int</code> <p>Max. timeout in seconds for one execution [default: 10].</p> required <code>--lines</code> <code>int</code> <p>Number lines of profiler stats to collect e.g. to profile top 10 methods, use <code>--lines 10</code>.</p> required <code>--skip</code> <code>str</code> <p>Space-separated list of files to exclude e.g., <code>--skip dense infinite_2</code> will not profile matching files.</p> required <code>--only</code> <code>str</code> <p>Space-separated list of files to include e.g., <code>--only dense empty</code> will profile only matching files.</p> required <code>--extern</code> <p>Exclude package external methods from cProfile results</p> required <code>--callers</code> <p>Include function caller statistics.</p> required <code>--save</code> <p>Save pymwp analysis results [default: False].</p> required"}]}